import json
import requests
import os
from urllib.parse import urlparse
import tempfile
import base64
from io import BytesIO
from cryptography.fernet import Fernet
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, CallbackContext, ContextTypes
from telegram.ext import ConversationHandler, MessageHandler
from telegram.ext import filters
from telegram import ReplyKeyboardRemove
from telegram.ext import ApplicationBuilder
import asyncio
import yaml
from datetime import datetime, timedelta
from pytz import timezone
from jdatetime import date as jdate 
from telegram import InputFile
from PIL import Image, ImageDraw, ImageFont
from bidi.algorithm import get_display
import arabic_reshaper
import re
import requests
from ipaddress import ip_address
import aiohttp
from io import BytesIO
import matplotlib
matplotlib.use('Agg')  
import matplotlib.pyplot as plt
import aiohttp
TOGGLE_BLOCK = 0  
SELECT_CONFIG = 1
SELECT_PEER = 2
TOGGLE_BLOCK_STATE = 3 
SHOW_BACKUPS = 4
CREATE_BACKUP = 5
DELETE_BACKUP = 6
RESTORE_BACKUP = 7
SELECT_PEER_NAME = 8
SELECT_INTERFACE = 9
STATE_SELECT_INTERFACE = 10
STATE_SELECT_PEER_OR_SEARCH = 11
STATE_SEARCH_PEER = 12
STATE_SELECT_PEER_TO_EDIT = 13
STATE_EDIT_OPTION = 60
STATE_SET_DATA_LIMIT = 61
STATE_SET_DNS = 62
STATE_SET_EXPIRY_TIME = 63
SET_DATA_LIMIT = 14
SET_DNS = 15
SET_EXPIRY_TIME = 16
SELECT_IP_ADDRESS = 17
INPUT_PEER_NAME = 18
SELECT_LIMIT_UNIT = 19
INPUT_LIMIT_VALUE = 20
SELECT_DNS = 21
INPUT_CUSTOM_DNS = 22
INPUT_EXPIRY_TIME = 23
CONFIRM_USAGE = 24
CHOOSE_WG_INTERFACE = 25
ENTER_PEER_NAME = 26
CONFIRM_PEER_DELETION = 27
SELECT_RESET_INTERFACE = 28
ENTER_RESET_PEER_NAME = 29
SHOW_PEER_INFO = 30
CONFIRM_RESET_ACTION = 31
CHOOSE_INTERFACE_STATUS = 32
INPUT_PEER_NAME_STATUS = 33
DISPLAY_PEER_STATUS = 34
USER_UPDATE = 35
PASSWORD_UPDATE = 36
CONFIG_INTERFACE = 37
CONFIG_DETAILS = 38
LOGIN_USERNAME = 39
LOGIN_PASSWORD = 40
CONFIG_PORT = 41
CONFIG_MTU = 42
CONFIG_DNS = 43
CONFIG_CONFIRM = 44
VIEW_TEMPLATE_PEER_NAME = 49
SELECT_TEMPLATE_INTERFACE = 50
CONFIRM_TEMPLATE = 51
SELECT_CONFIG_DYNAMIC = 52
VIEW_PEER_DETAILS = 53
SELECT_TEMPLATE_PEER = 54
INPUT_MTU = 55
INPUT_KEEPALIVE = 56
SELECT_MODE = 57
INPUT_BULK_COUNT = 58
INPUT_EXPIRY_DAYS = 59

def load_telegram_yaml():
    telegram_dir = os.path.dirname(os.path.abspath(__file__))
    yaml_path = os.path.join(telegram_dir, "telegram.yaml")
    secret_key_path = os.path.join(os.path.dirname(telegram_dir), "secret.key")

    try:
        if not os.path.exists(secret_key_path):
            raise FileNotFoundError(f"Secret key file not found at {secret_key_path}")
        
        with open(secret_key_path, "rb") as key_file:
            key = key_file.read()
        cipher = Fernet(key)

        if not os.path.exists(yaml_path):
            raise FileNotFoundError(f"Config file not found at {yaml_path}")
        
        with open(yaml_path, "r") as file:
            config = yaml.safe_load(file) or {}  
            encrypted_chat_ids = config.get("admin_chat_ids", [])

            if not encrypted_chat_ids:
                print("No admin chat IDs found in telegram.yaml.")
                return {"admin_chat_ids": []}
            
            chat_ids = [cipher.decrypt(chat_id.encode()).decode() for chat_id in encrypted_chat_ids]
            print(f"Decrypted admin_chat_ids: {chat_ids}")

            return {"admin_chat_ids": chat_ids}

    except FileNotFoundError as e:
        print(f"‚ùå Config file {yaml_path} or key file {secret_key_path} not found. Error: {e}")
        raise
    except Exception as e:
        print(f"‚ùå Error loading or decrypting {yaml_path}: {e}")
        raise

def load_config():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    config_path = os.path.join(script_dir, "config.json")
    
    try:
        with open(config_path, "r") as config_file:
            config = json.load(config_file)
            print(f"Loaded config: {config}")  
            return {
                "bot_token": config.get("bot_token", ""), 
                "base_url": config.get("base_url", ""),    
                "api_key": config.get("api_key", ""),      
            }
    except FileNotFoundError:
        print(f"‚ùå Config file {config_path} not found.")
        raise
    except json.JSONDecodeError as e:
        print(f"‚ùå Invalid JSON in {config_path}. {e}")
        raise

config = load_config()
API_BASE_URL = config["base_url"]
TELEGRAM_BOT_TOKEN = config["bot_token"]
if not TELEGRAM_BOT_TOKEN:
    print("bot_token is missing in config.json.")
    exit(1)
API_KEY = config["api_key"]
CONFIG_FILE = "telegram.yaml"


async def api_stuff(endpoint, method="GET", data=None, context=None, retries=3, timeout=30):
    url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json",
    }
    cookies = context.user_data.get("cookies", {}) if context else {}

    for attempt in range(1, retries + 1):
        async with aiohttp.ClientSession(cookies=cookies) as session:
            try:
                if method.upper() == "GET":
                    async with session.get(url, headers=headers, timeout=timeout) as response:
                        response.raise_for_status()
                        return await response.json()
                elif method.upper() == "POST":
                    async with session.post(url, headers=headers, json=data, timeout=timeout) as response:
                        response.raise_for_status()
                        if response.cookies and context:
                            context.user_data["cookies"] = {key: morsel.value for key, morsel in response.cookies.items()}
                        return await response.json()
                elif method.upper() == "DELETE":
                    async with session.delete(url, headers=headers, json=data, timeout=timeout) as response:
                        response.raise_for_status()
                        return await response.json()
                else:
                    return {"error": "HTTP method unsupported"}

            except aiohttp.ClientError as e:
                print(f"Attempt {attempt} failed: {str(e)}")
                if attempt < retries:
                    await asyncio.sleep(2)
                else:
                    return {"error": f"Request failed after {retries} attempts: {str(e)}"}

            except asyncio.TimeoutError:
                print(f"Attempt {attempt} timed out.")
                if attempt < retries:
                    await asyncio.sleep(2)
                else:
                    return {"error": f"Request timed out after {retries} attempts"}



def load_chat_ids():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r") as file:
            data = yaml.safe_load(file)
            return data.get("admin_chat_ids", [])  
    return []

def save_chat_ids(chat_ids):
    config = load_telegram_yaml()  
    config["admin_chat_ids"] = chat_ids  
    with open(CONFIG_FILE, "w") as file:
        yaml.dump(config, file, default_flow_style=False, indent=4)  

def clear_chat_ids():
    config = load_telegram_yaml() 
    if "admin_chat_ids" in config:
        del config["admin_chat_ids"]  
    with open(CONFIG_FILE, "w") as file:
        yaml.dump(config, file, default_flow_style=False, indent=4)  

admin_chat_ids = load_chat_ids()  
current_status = {"status": "inactive"}

async def monitor_health(context: CallbackContext):
    global current_status
    endpoint = "api/health"

    notifications_enabled = context.bot_data.get("notifications_enabled", False)  
    if not notifications_enabled:
        print("Health monitoring is disabled.")
        return

    try:
        response = await api_stuff(endpoint)
        new_status = "running" if response.get("status") == "running" else "inactive"
    except Exception:
        new_status = "inactive"

    if new_status != current_status["status"]:
        current_status["status"] = new_status

        config = load_telegram_yaml()
        admin_chat_ids = config.get("admin_chat_ids", [])

        for chat_id in admin_chat_ids:
            try:
                if new_status == "inactive":
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text="‚ö†Ô∏è *Ÿáÿ¥ÿØÿßÿ±*: ÿ®ÿ±ŸÜÿßŸÖŸá *ÿ∫€åÿ±ŸÅÿπÿßŸÑ* ÿ¥ÿØŸá ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã Ÿàÿ∂ÿπ€åÿ™ ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ!",
                        parse_mode="Markdown"
                    )
                elif new_status == "running":
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text="‚úÖ *ÿßÿ∑ŸÑÿßÿπ€åŸá*: ÿ®ÿ±ŸÜÿßŸÖŸá ÿØŸàÿ®ÿßÿ±Ÿá *ŸÅÿπÿßŸÑ* Ÿà ÿπŸÖŸÑ€åÿßÿ™€å ÿ¥ÿØ.",
                        parse_mode="Markdown"
                    )
            except Exception as e:
                print(f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ∑ŸÑÿßÿπ‚Äåÿ±ÿ≥ÿßŸÜ€å ÿ®Ÿá ŸÖÿØ€åÿ±: {e}")

    try:
        context.job_queue.run_once(monitor_health, 10)
    except Exception as e:
        print(f"ÿÆÿ∑ÿß ÿØÿ± ÿ≤ŸÖÿßŸÜ‚Äåÿ®ŸÜÿØ€å ŸÖÿ¨ÿØÿØ ŸÖÿßŸÜ€åÿ™Ÿàÿ±€åŸÜ⁄Ø : {e}")



async def start_login(update: Update, context: CallbackContext):
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        await query.message.reply_text(
            "üë§ *ŸÅÿ±ÿ¢€åŸÜÿØ Ÿàÿ±ŸàÿØ:*\n\nŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            parse_mode="Markdown"
        )
    else:
        await update.message.reply_text(
            "üë§ *ŸÅÿ±ÿ¢€åŸÜÿØ Ÿàÿ±ŸàÿØ:*\n\nŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            parse_mode="Markdown"
        )
    return LOGIN_USERNAME


async def login_username(update: Update, context: CallbackContext):
    context.user_data['login_username'] = update.message.text
    await update.message.reply_text(
        "üîí *ŸÅÿ±ÿ¢€åŸÜÿØ Ÿàÿ±ŸàÿØ:*\n\nŸÑÿ∑ŸÅÿßŸã ÿ±ŸÖÿ≤ ÿπÿ®Ÿàÿ± ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
        parse_mode="Markdown"
    )
    return LOGIN_PASSWORD


async def login_password(update: Update, context: CallbackContext):
    username = context.user_data['login_username']
    password = update.message.text

    payload = {"username": username, "password": password}

    try:
        response = await api_stuff("api/login", method="POST", data=payload, context=context)

        if response.get("message"):
            context.user_data['is_logged_in'] = True
            context.user_data['username'] = username

            await update.message.reply_text(
                f"‚úÖ *Ÿàÿ±ŸàÿØ ŸÖŸàŸÅŸÇ€åÿ™‚Äåÿ¢ŸÖ€åÿ≤!*\n\nÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØÿå `{username}`!",
                parse_mode="Markdown"
            )

            await settings_menu(update, context)
            return ConversationHandler.END
        else:
            await update.message.reply_text(
                f"‚ùå *Ÿàÿ±ŸàÿØ ŸÜÿßŸÖŸàŸÅŸÇ:*\n\n{response.get('error', 'ÿÆÿ∑ÿß€å ŸÜÿßÿ¥ŸÜÿßÿÆÿ™Ÿá')}\n\n"
                "ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿØÿ≥ÿ™Ÿàÿ± /login ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.",
                parse_mode="Markdown"
            )
            return ConversationHandler.END
    except Exception as e:
        await update.message.reply_text(
            f"‚ùå *ÿÆÿ∑ÿß:*\n\nŸÖÿ¥⁄©ŸÑ€å ÿ±ÿÆ ÿØÿßÿØ: `{e}`.\n\n"
            "ŸÑÿ∑ŸÅÿßŸã ÿ®ÿπÿØÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.",
            parse_mode="Markdown"
        )
        return ConversationHandler.END


async def auto_message(context: ContextTypes.DEFAULT_TYPE):
    config = load_telegram_yaml()
    admin_chat_ids = config.get("admin_chat_ids", [])

    if not admin_chat_ids:
        print("‚ùå Admin chat IDs not found in telegram.yaml.")
        return

    for chat_id in admin_chat_ids:
        try:
            await start(context=context, chat_id=chat_id)
        except Exception as e:
            print(f"‚ùå Failed to send auto message to chat_id {chat_id}: {e}")




def flask_status():
    global current_status
    config = load_config()
    flask_url = config["base_url"] + "/api/health"  

    try:
        response = requests.get(flask_url, timeout=5)
        if response.status_code == 200:
            data = response.json()
            if data.get("status") == "running":
                current_status['status'] = 'running'
                print("‚úÖ *ÿßÿ∑ŸÑÿßÿπ€åŸá*: ÿ®ÿ±ŸÜÿßŸÖŸá ÿØŸàÿ®ÿßÿ±Ÿá *ŸÅÿπÿßŸÑ* Ÿà ÿπŸÖŸÑ€åÿßÿ™€å ÿ¥ÿØ.")
            else:
                current_status['status'] = 'inactive'
                print(f"‚ö†Ô∏è Ÿáÿ¥ÿØÿßÿ±: Ÿàÿ∂ÿπ€åÿ™ ÿ∫€åÿ±ŸÖÿπŸÖŸàŸÑ ÿßÿ≤ API ÿØÿ±€åÿßŸÅÿ™ ÿ¥ÿØ: {data.get('status')}.")
        else:
            current_status['status'] = 'inactive'
            print(f"‚ö†Ô∏è Ÿáÿ¥ÿØÿßÿ±: API ÿß€åŸÜ ⁄©ÿØ Ÿàÿ∂ÿπ€åÿ™ ÿ±ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿØ: {response.status_code}.")
    except requests.exceptions.RequestException as e:
        current_status['status'] = 'inactive'
        print(f"‚ùå ÿßŸÖ⁄©ÿßŸÜ ÿßÿ™ÿµÿßŸÑ ÿ®Ÿá API Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ. ÿ¨ÿ≤ÿ¶€åÿßÿ™: {e}")


    
async def start(update: Update = None, context: CallbackContext = None, chat_id: int = None):
    global current_status

    if chat_id is None:
        chat_id = update.effective_chat.id if update else None

    config = load_telegram_yaml()
    admin_chat_ids = config.get("admin_chat_ids", [])

    if not str(chat_id) in map(str, admin_chat_ids):  
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå ÿ¥ŸÖÿß ŸÖÿ¨ÿßÿ≤ ÿ®Ÿá ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿß€åŸÜ ÿ±ÿ®ÿßÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.",
            parse_mode="Markdown"
        )
        return

    try:
        flask_status()
    except Exception as e:
        print(f"ÿ®ÿ±ÿ±ÿ≥€å ÿ≥ŸÑÿßŸÖÿ™ ÿØÿ≥ÿ™€å ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ: {e}")

    script_dir = os.path.dirname(os.path.abspath(__file__))
    image_path = os.path.join(script_dir, "static/images/telegram.jpg")

    status_icon = "üö¶"
    status_message = (
        f"{status_icon} Ÿàÿ∂ÿπ€åÿ™ ÿ®ÿ±ŸÜÿßŸÖŸá: {'üü¢ ŸÅÿπÿßŸÑ' if current_status['status'] == 'running' else 'üî¥ ÿ∫€åÿ±ŸÅÿπÿßŸÑ'}"
    )

    notifications_enabled = context.bot_data.get("notifications_enabled", False)  
    notification_status = "‚úÖ ŸÅÿπÿßŸÑ" if notifications_enabled else "‚ùå ÿ∫€åÿ±ŸÅÿπÿßŸÑ"

    caption_text = (
        f"<b>ÿ®Ÿá ÿ±ÿ®ÿßÿ™ ŸÖÿØ€åÿ±€åÿ™ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ</b>\n\n"
        f"{status_message}\n"
        f"üì¢ ÿßÿπŸÑÿßŸÜ‚ÄåŸáÿß: {notification_status}\n\n"
        f"<i>ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:</i>"
    )

    keyboard = [
        [
            InlineKeyboardButton("üîï ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿßÿπŸÑÿßŸÜ‚ÄåŸáÿß", callback_data="disable_notifications"),
            InlineKeyboardButton("üîî ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿßÿπŸÑÿßŸÜ‚ÄåŸáÿß", callback_data="enable_notifications"),
        ],
        [
            InlineKeyboardButton("üìä ÿ¢ŸÖÿßÿ±", callback_data="metrics"),
            InlineKeyboardButton("üë• ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu"),
        ],
        [
            InlineKeyboardButton("‚öôÔ∏è ÿ™ŸÜÿ∏€åŸÖÿßÿ™", callback_data="settings_menu"),
            InlineKeyboardButton("üì¶ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß", callback_data="backups_menu"),
        ],
        [InlineKeyboardButton("üìù ⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™", callback_data="view_logs")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    try:
        if os.path.exists(image_path):
            with open(image_path, "rb") as photo_file:
                await context.bot.send_photo(
                    chat_id=chat_id,
                    photo=photo_file,
                    caption=caption_text,
                    parse_mode="HTML",
                    reply_markup=reply_markup,
                )
                print("ÿ™ÿµŸà€åÿ± ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ.")
        else:
            print(f"ÿ™ÿµŸà€åÿ± ÿØÿ± ŸÖÿ≥€åÿ± {image_path} €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ™ÿµŸà€åÿ± ÿßŸÖ⁄©ÿßŸÜ‚ÄåŸæÿ∞€åÿ± ŸÜ€åÿ≥ÿ™.",
            )
    except Exception as e:
        print(f"ÿßÿ±ÿ≥ÿßŸÑ ÿ™ÿµŸà€åÿ± ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ: {e}")
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå ÿßÿ±ÿ≥ÿßŸÑ ÿ™ÿµŸà€åÿ± ÿßŸÖ⁄©ÿßŸÜ‚ÄåŸæÿ∞€åÿ± ŸÜ€åÿ≥ÿ™.",
        )




async def view_logs(update: Update, context: CallbackContext):
    query = update.callback_query
    chat_id = update.effective_chat.id

    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return

    await query.answer()

    try:
        response = await api_stuff("api/logs?limit=20", method="GET", context=context)
        
        if "logs" in response:
            logs = "\n".join(response["logs"])
            message = f"üìù *⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™:*\n\n```\n{logs}\n```"
        else:
            message = "‚ö†Ô∏è Ÿá€å⁄Ü ⁄Øÿ≤ÿßÿ±ÿ¥€å ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™ €åÿß ŸÖÿ¥⁄©ŸÑ€å ÿ±ÿÆ ÿØÿßÿØŸá ÿßÿ≥ÿ™."
    except Exception as e:
        message = f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™: `{e}`"

    keyboard = [
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(
        message, 
        parse_mode="Markdown", 
        reply_markup=reply_markup
    )



async def settings_menu(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id

    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return

    if update.callback_query:
        query = update.callback_query
        await query.answer()
        message_target = query.message  
    else:
        message_target = update.message 

    is_logged_in = context.user_data.get('is_logged_in', False)
    username = context.user_data.get('username', 'Ÿàÿßÿ±ÿØ ŸÜÿ¥ÿØŸá')

    if is_logged_in:
        message = (
            f"‚öôÔ∏è *ŸÖŸÜŸà€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™:*\n\n"
            f"üë§ *Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ÿ®Ÿá ÿ≥ÿ±Ÿàÿ±:* `{username}`\n\n"
            f"€å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿ®ÿ±ÿß€å ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
        )
        keyboard = [
            [InlineKeyboardButton("üë§ ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å/ÿ±ŸÖÿ≤ ÿπÿ®Ÿàÿ±", callback_data="update_user")],
            [InlineKeyboardButton("üîß ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ", callback_data="update_wireguard_config")],
            [InlineKeyboardButton("üö™ ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ÿ≠ÿ≥ÿßÿ®", callback_data="logout")],
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")],
        ]
    else:
        message = (
            f"‚öôÔ∏è *ŸÖŸÜŸà€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™:*\n\n"
            f"‚ùå *ÿ¥ŸÖÿß Ÿàÿßÿ±ÿØ ÿ≥ÿ±Ÿàÿ± ŸÜÿ¥ÿØŸá‚Äåÿß€åÿØ.*\n\n"
            f"ŸÑÿ∑ŸÅÿßŸã ÿ®ÿ±ÿß€å ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ®Ÿá ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ≥ÿ±Ÿàÿ±ÿå Ÿàÿßÿ±ÿØ ÿ¥Ÿà€åÿØ."
        )
        keyboard = [
            [InlineKeyboardButton("üîë Ÿàÿ±ŸàÿØ", callback_data="login")],
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")],
        ]

    reply_markup = InlineKeyboardMarkup(keyboard)
    await message_target.reply_text(message, reply_markup=reply_markup, parse_mode="Markdown")

async def update_user_wire(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    if not context.user_data.get('is_logged_in', False):
        await query.message.reply_text(
            "‚ùå *ÿ®ÿ±ÿß€å ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ≠ÿ≥ÿßÿ® ÿÆŸàÿØ ÿ®ÿß€åÿØ Ÿàÿßÿ±ÿØ ÿ¥Ÿà€åÿØ.*\n\nÿßÿ≤ ÿØÿ≥ÿ™Ÿàÿ± /login ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    await query.message.reply_text(
        "üë§ *ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å:*\n\nŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ÿ¨ÿØ€åÿØ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
        parse_mode="Markdown"
    )
    return USER_UPDATE

async def logout(update: Update, context: CallbackContext):
    response = await api_stuff("api/logout", method="POST", context=context)

    context.user_data.clear()
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        message_target = query.message  
    elif update.message:
        message_target = update.message  
    else:
        print("‚ùå ÿÆÿ±Ÿàÿ¨ ÿßŸÖ⁄©ÿßŸÜ Ÿæÿ∞€åÿ± ŸÜ€åÿ≥ÿ™")
        return

    await message_target.reply_text(
        "üö™ *ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßÿ≤ ÿ≥ÿ±Ÿàÿ± ÿÆÿßÿ±ÿ¨ ÿ¥ÿØ€åÿØ!*\n\nÿ®ÿ±ÿß€å Ÿàÿ±ŸàÿØ ÿØŸàÿ®ÿßÿ±Ÿá ÿßÿ≤ ÿØÿ≥ÿ™Ÿàÿ± /login ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.",
        parse_mode="Markdown"
    )


async def update_username(update: Update, context: CallbackContext):
    new_username = update.message.text
    context.user_data['new_username'] = new_username
    await update.message.reply_text(
        "üîí *ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ±ŸÖÿ≤ ÿπÿ®Ÿàÿ±:*\n\nŸÑÿ∑ŸÅÿßŸã ÿ±ŸÖÿ≤ ÿπÿ®Ÿàÿ± ÿ¨ÿØ€åÿØ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
        parse_mode="Markdown"
    )
    return PASSWORD_UPDATE


async def update_password(update: Update, context: CallbackContext):
    new_password = update.message.text
    new_username = context.user_data['new_username']

    payload = {"username": new_username, "password": new_password}
    cookies = context.user_data.get("cookies", {})  

    try:
        response = await api_stuff(
            "api/update-user",
            method="POST",
            data=payload,
            context=context
        )

        if response.get("message"):
            context.user_data['username'] = new_username  
            await update.message.reply_text(
                f"‚úÖ {response['message']}\n\nÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™...",
                parse_mode="Markdown"
            )
            await settings_menu(update, context)
            return ConversationHandler.END
        else:
            await update.message.reply_text(
                f"‚ùå *ÿÆÿ∑ÿß:*\n\n{response.get('error', 'ÿÆÿ∑ÿß€å ŸÜÿßÿ¥ŸÜÿßÿÆÿ™Ÿá')}\n\nÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™...",
                parse_mode="Markdown"
            )
            await settings_menu(update, context)
            return ConversationHandler.END
    except Exception as e:
        await update.message.reply_text(
            f"‚ùå ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ⁄©ÿßÿ±ÿ®ÿ± ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÖ€åÿ≤ ŸÜÿ®ŸàÿØ: `{e}`\n\nÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™...",
            parse_mode="Markdown"
        )
        await settings_menu(update, context)
        return ConversationHandler.END



async def back_to_settings(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()
    await settings_menu(update, context)
    return ConversationHandler.END


async def update_wireguard_setting(update: Update, context: CallbackContext):
    await update.callback_query.answer()

    interface = context.user_data.get("selected_interface", "wg0.conf")
    context.user_data["interface"] = interface
    message = f"‚úèÔ∏è *ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿ±ÿß€å {interface}:*\n\n€å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
    keyboard = [
        [InlineKeyboardButton("üõ†Ô∏è ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸæŸàÿ±ÿ™", callback_data="update_port")],
        [InlineKeyboardButton("üìè ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å MTU", callback_data="update_mtu")],
        [InlineKeyboardButton("üåê ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å DNS", callback_data="update_dns")],
        [InlineKeyboardButton("‚úÖ ÿßÿπŸÖÿßŸÑ ÿ™ÿ∫€å€åÿ±ÿßÿ™", callback_data="apply_changes")],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿ™ŸÜÿ∏€åŸÖÿßÿ™", callback_data="settings_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.callback_query.message.reply_text(message, reply_markup=reply_markup, parse_mode="Markdown")
    return CONFIG_INTERFACE


#not using it
async def select_interface(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()
    interface = query.data.replace("select_interface_", "")
    context.user_data['interface'] = interface

    await query.message.reply_text(
        f"‚úèÔ∏è *Update Configuration for {interface}:*\n\n"
        f"Please send the configuration in the following format:\n"
        f"`port=<value>, mtu=<value>, dns=<value>`",
        parse_mode="Markdown"
    )
    return CONFIG_DETAILS

async def ask_for_port(update: Update, context: CallbackContext):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text(
        "üîß *ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸæŸàÿ±ÿ™:*\n\nŸÑÿ∑ŸÅÿßŸã ŸæŸàÿ±ÿ™ ÿ¨ÿØ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.\n\nŸÖÿ´ÿßŸÑ: `51820`",
        parse_mode="Markdown"
    )
    return CONFIG_PORT


async def ask_for_mtu(update: Update, context: CallbackContext):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text(
        "üìè *ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å MTU:*\n\n"
        "ŸÑÿ∑ŸÅÿßŸã ŸÖŸÇÿØÿßÿ± ÿ¨ÿØ€åÿØ MTU ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.\n\n"
        "ŸÖŸÇÿØÿßÿ± MTU ÿ®ÿß€åÿØ ÿ®€åŸÜ `1280` Ÿà `1420` ÿ®ÿßÿ¥ÿØ.\n\n"
        "ŸÖÿ´ÿßŸÑ: `1420`",
        parse_mode="Markdown"
    )
    return CONFIG_MTU


async def ask_for_dns(update: Update, context: CallbackContext):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text(
        "üåê *ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å DNS:*\n\nŸÑÿ∑ŸÅÿßŸã ÿ≥ÿ±Ÿàÿ±(Ÿáÿß€å) DNS ÿ¨ÿØ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.\n\nŸÖÿ´ÿßŸÑ: `8.8.8.8, 8.8.4.4`",
        parse_mode="Markdown"
    )
    return CONFIG_DNS


async def set_port(update: Update, context: CallbackContext):
    port = update.message.text
    context.user_data["port"] = port
    await update.message.reply_text(f"‚úÖ ŸæŸàÿ±ÿ™ ÿ®Ÿá `{port}` ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ.\n\n⁄Øÿ≤€åŸÜŸá ÿØ€å⁄Øÿ±€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ÿ™ÿ∫€å€åÿ±ÿßÿ™ ÿ±ÿß ÿßÿπŸÖÿßŸÑ ⁄©ŸÜ€åÿØ.",
                                    parse_mode="Markdown")
    await update_wireguard_setting(update, context)
    return CONFIG_INTERFACE


async def set_mtu(update: Update, context: CallbackContext):
    mtu = update.message.text.strip()

    if not mtu.isdigit() or not (1280 <= int(mtu) <= 1420):
        await update.message.reply_text(
            "‚ùå ŸÖŸÇÿØÿßÿ± MTU ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ŸÖŸÇÿØÿßÿ±€å ÿ®€åŸÜ `1280` Ÿà `1420` Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.",
            parse_mode="Markdown"
        )
        return CONFIG_MTU

    context.user_data["mtu"] = int(mtu)

    keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™", callback_data="settings_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        f"‚úÖ ŸÖŸÇÿØÿßÿ± MTU ÿ®Ÿá `{mtu}` ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ.\n\n"
        "ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿ®Ÿá ŸÖŸÜŸà€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ €åÿß ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿØ€å⁄Øÿ±€å ÿ±ÿß ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ⁄©ŸÜ€åÿØ.",
        parse_mode="Markdown",
        reply_markup=reply_markup
    )
    return CONFIG_INTERFACE



async def set_dns(update: Update, context: CallbackContext):
    dns = update.message.text
    context.user_data["dns"] = dns
    await update.message.reply_text(f"‚úÖ DNS ÿ®Ÿá `{dns}` ÿ®ÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ.\n\n⁄Øÿ≤€åŸÜŸá ÿØ€å⁄Øÿ±€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ÿ™ÿ∫€å€åÿ±ÿßÿ™ ÿ±ÿß ÿßÿπŸÖÿßŸÑ ⁄©ŸÜ€åÿØ.",
                                    parse_mode="Markdown")
    await update_wireguard_setting(update, context)
    return CONFIG_INTERFACE


async def apply_config(update: Update, context: CallbackContext):
    await update.callback_query.answer()

    interface = context.user_data.get("interface")
    port = context.user_data.get("port", "ÿ™ŸÜÿ∏€åŸÖ ŸÜÿ¥ÿØŸá")
    mtu = context.user_data.get("mtu", "ÿ™ŸÜÿ∏€åŸÖ ŸÜÿ¥ÿØŸá")
    dns = context.user_data.get("dns", "ÿ™ŸÜÿ∏€åŸÖ ŸÜÿ¥ÿØŸá")

    payload = {"config": interface, "port": port, "mtu": mtu, "dns": dns}
    response = await api_stuff("api/update-wireguard-config", method="POST", data=payload, context=context)

    if response.get("message"):
        await update.callback_query.message.reply_text(
            f"‚úÖ *ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®ÿ±ÿß€å {interface} ÿßÿπŸÖÿßŸÑ ÿ¥ÿØ:*\n\n"
            f"ŸæŸàÿ±ÿ™: `{port}`\nMTU: `{mtu}`\nDNS: `{dns}`",
            parse_mode="Markdown"
        )
    else:
        await update.callback_query.message.reply_text(
            f"‚ùå *ÿßÿπŸÖÿßŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿ±ÿß€å {interface} ÿ¥⁄©ÿ≥ÿ™ ÿÆŸàÿ±ÿØ:*\n\n"
            f"ÿÆÿ∑ÿß: {response.get('error', 'ÿÆÿ∑ÿß€å ŸÜÿßÿ¥ŸÜÿßÿÆÿ™Ÿá')}",
            parse_mode="Markdown"
        )

    await update_wireguard_setting(update, context)
    return CONFIG_INTERFACE


def is_authorized(chat_id):
    config = load_telegram_yaml()
    admin_chat_ids = config["admin_chat_ids"]  

    print(f"Checking authorization for chat_id: {chat_id}, admin_chat_ids: {admin_chat_ids}")
    return str(chat_id) in map(str, admin_chat_ids)  


async def enable_notifications(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id

    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå ÿ¥ŸÖÿß ŸÖÿ¨ÿßÿ≤ ÿ®Ÿá ÿßŸÜÿ¨ÿßŸÖ ÿß€åŸÜ ÿπŸÖŸÑ€åÿßÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.",
            parse_mode="Markdown"
        )
        return

    context.bot_data["notifications_enabled"] = True

    context.job_queue.run_once(monitor_health, 10)

    keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.callback_query.answer()
    await update.callback_query.message.reply_text(
        f"‚úÖ ÿßÿπŸÑÿßŸÜ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ÿß€åŸÜ ⁄Üÿ™ ŸÅÿπÿßŸÑ ÿ¥ÿØŸÜÿØ.",
        parse_mode="Markdown",
        reply_markup=reply_markup
    )

async def disable_notifications(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id

    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå ÿ¥ŸÖÿß ŸÖÿ¨ÿßÿ≤ ÿ®Ÿá ÿßŸÜÿ¨ÿßŸÖ ÿß€åŸÜ ÿπŸÖŸÑ€åÿßÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.",
            parse_mode="Markdown"
        )
        return

    context.bot_data["notifications_enabled"] = False

    current_jobs = context.job_queue.jobs()
    for job in current_jobs:
        if job.name == "monitor_health":
            job.schedule_removal()

    keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.callback_query.answer()
    await update.callback_query.message.reply_text(
        f"‚ùå ÿßÿπŸÑÿßŸÜ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ÿß€åŸÜ ⁄Üÿ™ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿ¥ÿØŸÜÿØ.\n\nŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿßÿ≤ ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿØŸàÿ®ÿßÿ±Ÿá ÿ¢ŸÜ‚ÄåŸáÿß ÿ±ÿß ŸÅÿπÿßŸÑ ⁄©ŸÜ€åÿØ.",
        parse_mode="Markdown",
        reply_markup=reply_markup
    )



def register_notification(application):
    application.add_handler(CallbackQueryHandler(enable_notifications, pattern="enable_notifications"))
    application.add_handler(CallbackQueryHandler(disable_notifications, pattern="disable_notifications"))

async def backups_menu(update: Update, context: CallbackContext):
    query = update.callback_query
    chat_id = update.effective_chat.id

    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return

    await query.answer()

    keyboard = [
        [InlineKeyboardButton("üìã ŸÜŸÖÿß€åÿ¥ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß", callback_data="show_backups"),
         InlineKeyboardButton("‚ûï ÿß€åÿ¨ÿßÿØ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ", callback_data="create_backup")],
        [InlineKeyboardButton("üóë ÿ≠ÿ∞ŸÅ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ", callback_data="delete_backup"),
         InlineKeyboardButton("üîÑ ÿ®ÿßÿ≤€åÿßÿ®€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ", callback_data="restore_backup")],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text(
        "üì¶ *ŸÖŸÜŸà€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß:*\n\n⁄ÜŸá ⁄©ÿßÿ±€å ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØÿü",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )


def fish_public_ip():
    try:
        response = requests.get("https://api.ipify.org?format=json", timeout=5)
        response.raise_for_status()
        return response.json().get("ip", "localhost")
    except Exception as e:
        print(f"Error retrieving public IP: {e}")
        return "localhost" 
    
def determine_base_url(config):
    base_url = config.get("base_url", "http://localhost").strip()  
    
    parsed_url = urlparse(base_url)
    
    if parsed_url.port:
        return f"{parsed_url.scheme}://{parsed_url.hostname}:{parsed_url.port}"
    
    if base_url.startswith("http://localhost") or base_url == "localhost":
        public_ip = fish_public_ip()
        return f"http://{public_ip}"
    
    if re.match(r"^https?://[a-zA-Z0-9.-]+", base_url):
        return base_url.rstrip("/")
    
    print(f"Warning: Invalid base_url in config: {base_url}. Defaulting to localhost.")
    return "http://localhost"


async def show_backups(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    query = update.callback_query
    await query.answer()

    response = await api_stuff("api/backups")
    if "error" in response:
        await query.message.reply_text(f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß:* `{response['error']}`", parse_mode="Markdown")
        return await backups_menu(update, context)

    backups = response.get("backups", [])
    if not backups:
        await query.message.reply_text("‚ö†Ô∏è *Ÿá€å⁄Ü Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ ÿØÿ≥ÿ™€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*", parse_mode="Markdown")
        return await backups_menu(update, context)

    base_url = determine_base_url(config)

    keyboard = [
        [
            InlineKeyboardButton(f"üìÑ {backup}", callback_data=f"show_backup_details_{backup}"),
            InlineKeyboardButton("‚¨áÔ∏è ÿØÿßŸÜŸÑŸàÿØ", url=f"{base_url}/api/download-backup?name={backup}"),
        ]
        for backup in backups
    ]
    keyboard.append([InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß", callback_data="backups_menu")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text(
        "üì¶ *Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß€å ŸÖŸàÿ¨ŸàÿØ:*\n\n€å⁄© Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ŸÖÿ≥ÿ™ŸÇ€åŸÖÿßŸã ÿØÿßŸÜŸÑŸàÿØ ⁄©ŸÜ€åÿØ:",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )




async def create_backup(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    query = update.callback_query
    await query.answer()

    response = await api_stuff("api/create-backup", method="POST")
    if "error" in response:
        await query.message.reply_text(f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿß€åÿ¨ÿßÿØ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ:* `{response['error']}`", parse_mode="Markdown")
    else:
        message = response.get("message", "Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ.")
        await query.message.reply_text(f"‚úÖ {message}", parse_mode="Markdown")

    keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß", callback_data="backups_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text("⁄ÜŸá ⁄©ÿßÿ±€å ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØÿü", reply_markup=reply_markup)


async def delete_backup_apply(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    response = await api_stuff("api/backups")
    if "error" in response:
        await query.message.reply_text(f"‚ùå *Fetching backups error:* `{response['error']}`", parse_mode="Markdown")
        return ConversationHandler.END

    backups = response.get("backups", [])
    if not backups:
        await query.message.reply_text("‚ö†Ô∏è *No manual backups found.*", parse_mode="Markdown")
        return await backups_menu(update, context)

    keyboard = [
        [InlineKeyboardButton(f"üóë {backup}", callback_data=f"delete_{backup}")]
        for backup in backups
    ]
    keyboard.append([InlineKeyboardButton("üîô Back", callback_data="backups_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(
        "üóë **Select a backup to delete:**",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

async def delete_backup(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    backup_name = query.data.replace("delete_", "")
    print(f"Parsed backup name: {backup_name}")  

    response = await api_stuff(f"api/delete-backup?name={backup_name}&folder=root", method="DELETE")
    if "error" in response:
        await query.message.reply_text(f"‚ùå *Error deleting backup:* `{response['error']}`", parse_mode="Markdown")
    else:
        message = response.get("message", f"üóë *Backup `{backup_name}` deleted successfully.*")
        await query.message.reply_text(f"‚úÖ {message}", parse_mode="Markdown")

    return await backups_menu(update, context)



async def restore_backup_apply(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    query = update.callback_query
    await query.answer()
    response = await api_stuff("api/backups")
    if "error" in response:
        await query.message.reply_text(f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß:* `{response['error']}`", parse_mode="Markdown")
        return ConversationHandler.END

    backups = response.get("backups", [])
    if not backups:
        await query.message.reply_text("‚ö†Ô∏è *Ÿá€å⁄Ü Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ ÿØÿ≥ÿ™€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*", parse_mode="Markdown")
        await backups_menu(update, context)
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton(f"üîÑ {backup}", callback_data=f"restore_{backup}")]
        for backup in backups
    ]
    keyboard.append([InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="backups_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(
        "üîÑ *€å⁄© ŸÅÿß€åŸÑ Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ ÿ±ÿß ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤€åÿßÿ®€å ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )


async def restore_backup(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    backup_name = query.data.replace("restore_", "")
    response = await api_stuff("api/restore-backup", method="POST", data={"backupName": backup_name})
    if "error" in response:
        await query.message.reply_text(f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ≤€åÿßÿ®€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ:* `{response['error']}`", parse_mode="Markdown")
    else:
        message = response.get("message", f"üîÑ *Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ `{backup_name}` ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®ÿßÿ≤€åÿßÿ®€å ÿ¥ÿØ.*")
        await query.message.reply_text(f"‚úÖ {message}", parse_mode="Markdown")

    keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ‚ÄåŸáÿß", callback_data="backups_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text("⁄ÜŸá ⁄©ÿßÿ±€å ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØÿü", reply_markup=reply_markup)


def register_backup_stuff(application):
    application.add_handler(CallbackQueryHandler(backups_menu, pattern="backups_menu"))
    application.add_handler(CallbackQueryHandler(show_backups, pattern="show_backups"))
    application.add_handler(CallbackQueryHandler(create_backup, pattern="create_backup"))
    application.add_handler(CallbackQueryHandler(delete_backup_apply, pattern="delete_backup"))
    application.add_handler(CallbackQueryHandler(restore_backup_apply, pattern="restore_backup"))
    application.add_handler(CallbackQueryHandler(delete_backup, pattern="delete_.*"))
    application.add_handler(CallbackQueryHandler(restore_backup, pattern="restore_.*"))


async def stat_metrics(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    response = await api_stuff("api/metrics")
    if "error" in response:
        await context.bot.send_message(chat_id, text=f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿ¢ŸÖÿßÿ± ÿ≥€åÿ≥ÿ™ŸÖ: {response['error']}")
        return

    cpu = response.get("cpu", "Unknown")
    ram = response.get("ram", "Unknown")
    disk = response.get("disk", {"used": "Unknown", "total": "Unknown"})
    uptime = response.get("uptime", "Unknown")

    disk_used = float(disk["used"].replace("GB", "").strip()) if "used" in disk else 0
    disk_total = float(disk["total"].replace("GB", "").strip()) if "total" in disk else 1
    disk_percentage = (disk_used / disk_total) * 100 if disk_total > 0 else 0

    metrics_labels = ["CPU Usage", "RAM Usage", "Disk Usage"]
    metrics_values = [
        float(cpu.replace("%", "")) if "%" in cpu else 0,
        float(ram.replace("%", "")) if "%" in ram else 0,
        disk_percentage,
    ]

    plt.rcParams["axes.unicode_minus"] = False
    plt.rcParams["font.family"] = "DejaVu Sans"  

    plt.figure(figsize=(6, 4))
    plt.bar(metrics_labels, metrics_values, color=["blue", "green", "orange"])
    plt.title("System Metrics", fontsize=14)
    plt.ylabel("Percentage / GB", fontsize=12)
    plt.ylim(0, 100)
    plt.xticks(fontsize=10)
    plt.yticks(fontsize=10)
    plt.grid(axis="y", linestyle="--", linewidth=0.5)

    buffer = BytesIO()
    plt.savefig(buffer, format="png", bbox_inches="tight", dpi=150)
    buffer.seek(0)

    keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_photo(
        chat_id,
        photo=buffer,
        caption=f"üìä **ÿ¢ŸÖÿßÿ± ÿ≥€åÿ≥ÿ™ŸÖ**\n\n"
                f"CPU: {cpu}\n"
                f"RAM: {ram}\n"
                f"DISK: {disk['used']} / {disk['total']}\n"
                f"Uptime: {uptime}",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    buffer.close()


async def peers_menu(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id

    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return

    message = (
        "üéõ **ŸÖŸÜŸà€å ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ**\n\n"
        "€å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ±ÿß ÿ®ÿ±ÿß€å ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
    )

    keyboard = [
        [
            InlineKeyboardButton("‚úèÔ∏è Ÿà€åÿ±ÿß€åÿ¥ ⁄©ÿßÿ±ÿ®ÿ±", callback_data="edit_peer"),
            InlineKeyboardButton("üÜï ÿß€åÿ¨ÿßÿØ ⁄©ÿßÿ±ÿ®ÿ± ÿ¨ÿØ€åÿØ", callback_data="create_peer"),
        ],
        [
            InlineKeyboardButton("üîÑ ÿ±€åÿ≥ÿ™ ÿ™ÿ±ÿßŸÅ€å⁄©/ÿßŸÜŸÇÿ∂ÿß", callback_data="reset_peer"),
            InlineKeyboardButton("‚ùå ÿ≠ÿ∞ŸÅ ⁄©ÿßÿ±ÿ®ÿ±", callback_data="peer_delete"),
        ],
        [
            InlineKeyboardButton("üîí ŸÖÿ≥ÿØŸàÿØ/ÿ®ÿßÿ≤ ⁄©ÿ±ÿØŸÜ ⁄©ÿßÿ±ÿ®ÿ±", callback_data="block_unblock_peer"),
            InlineKeyboardButton("üîç Ÿàÿ∂ÿπ€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±", callback_data="peer_status"),
        ],
        [
            InlineKeyboardButton("üìÑ ŸÖÿ¥ÿßŸáÿØŸá ŸÇÿßŸÑÿ®", callback_data="view_template"),
            InlineKeyboardButton("‚¨áÔ∏è ÿØÿßŸÜŸÑŸàÿØ / ⁄©ÿØ QR", callback_data="download_qr_menu"),
        ],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")],
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(chat_id=chat_id, text=message, reply_markup=reply_markup, parse_mode="Markdown")



async def download_qr_menu(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()
    await query.message.reply_text(
        "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ŸÜŸÖÿß€å€åÿØ* \n\n"
        "ŸÖÿ´ÿßŸÑ : azumi",
        parse_mode="Markdown"
    )
    return VIEW_PEER_DETAILS

async def view_template_menu(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    response = await api_stuff("api/get-interfaces")
    if "error" in response:
        await query.message.reply_text(
            f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥‚ÄåŸáÿß:* `{response['error']}`",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    interfaces = response.get("interfaces", [])
    if not interfaces:
        await query.message.reply_text(
            "‚ùå *Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Wireguard €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton(f"üåê {interface}", callback_data=f"select_template_interface_{interface}")]
        for interface in interfaces
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(
        "üåê *ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Wireguard ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    return SELECT_TEMPLATE_INTERFACE


async def wire_int_selection(update: Update, context: CallbackContext):
    query = update.callback_query
    selected_interface = query.data.replace("select_template_interface_", "")
    context.user_data["selected_interface"] = selected_interface

    await query.answer()
    await query.message.reply_text(
        f"üåê ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØŸá: {selected_interface}.\n\n"
        "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ ÿ™ÿß ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß€å ÿß€åŸÜ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ ÿ±ÿß ÿ¨ÿ≥ÿ™ÿ¨Ÿà ⁄©ŸÜ€åÿØ:*",
        parse_mode="Markdown"
    )
    return VIEW_TEMPLATE_PEER_NAME


async def view_peers_with_name(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    selected_interface = context.user_data.get("selected_interface")
    API_BASE_URL = config.get("base_url")

    if not selected_interface:
        await update.message.reply_text(
            "‚ùå Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Wireguard ÿßŸÜÿ™ÿÆÿßÿ® ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ŸÅÿ±ÿ¢€åŸÜÿØ ÿ±ÿß ŸÖÿ¨ÿØÿØÿßŸã ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ.",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    if not API_BASE_URL:
        await update.message.reply_text(
            "‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿæ€å⁄©ÿ±ÿ®ŸÜÿØ€å: `base_url` ÿØÿ± Ÿæ€å⁄©ÿ±ÿ®ŸÜÿØ€å ÿ™ŸÜÿ∏€åŸÖ ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™.",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    try:
        response = requests.get(
        f"{API_BASE_URL}/api/get-peers",
        params={"peer_name": peer_name, "config_name": selected_interface},
        timeout=5  
        )
        if response.status_code != 200:
            await update.message.reply_text(
                f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß: {response.text}",
                parse_mode="Markdown"
            )
            return ConversationHandler.END

        peers_data = response.json().get("peers", [])
        if not peers_data:
            await update.message.reply_text(
                f"‚ùå Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß ŸÜÿßŸÖ `{peer_name}` ÿØÿ± ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ `{selected_interface}` €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.",
                parse_mode="Markdown"
            )
            return ConversationHandler.END

        for peer in peers_data:
            peer_details = (
                f"üñß *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:* `{peer['peer_name']}`\n"
                f"üåê *ÿ¢€å‚ÄåŸæ€å ⁄©ÿßÿ±ÿ®ÿ±:* `{peer.get('peer_ip', 'N/A')}`\n"
                f"üìä *ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿØÿßÿØŸá:* `{peer.get('limit', 'N/A')}`\n"
                f"‚è≥ *ÿßŸÜŸÇÿ∂ÿß:* `{peer['expiry_time'].get('months', 0)} ŸÖÿßŸá, "
                f"{peer['expiry_time'].get('days', 0)} ÿ±Ÿàÿ≤`\n"
            )
            keyboard = [
                [InlineKeyboardButton(
                    f"ŸÖÿ¥ÿßŸáÿØŸá ŸÇÿßŸÑÿ® {peer['peer_name']} ({peer.get('peer_ip', 'N/A')})",
                    callback_data=(f"view_template_{peer['peer_name']}_{peer['peer_ip']}_"
                                   f"{peer.get('limit', 'N/A')}_"
                                   f"{peer['expiry_time'].get('months', 0)}m_{peer['expiry_time'].get('days', 0)}d")
                )]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(peer_details, reply_markup=reply_markup, parse_mode="Markdown")

    except Exception as e:
        await update.message.reply_text(
            f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß: {str(e)}",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    return SELECT_TEMPLATE_PEER


def draw_rounded_rectangle(draw, xy, radius, fill, outline=None, outline_width=1):
    x0, y0, x1, y1 = xy
    draw.rounded_rectangle(xy, radius=radius, fill=fill, outline=outline, width=outline_width)

async def generate_template_with_qr(update, context):
    query = update.callback_query
    await query.answer()

    API_BASE_URL = config.get("base_url")
    if not API_BASE_URL:
        await query.message.reply_text(
            "‚ùå Config error: `base_url` is not set in the config.",
            parse_mode="Markdown"
        )
        return

    callback_data = query.data.replace("view_template_", "")
    peer_name, peer_ip, data_limit, expiry = callback_data.split("_", 3)
    selected_interface = context.user_data.get("selected_interface")

    expiry = expiry.replace("m_", " months, ").replace("d", " days")

    try:
        details_response = requests.post(
            f"{API_BASE_URL}/api/generate-template",
            json={"peer_name": peer_name, "config_name": selected_interface},
            timeout=5
        )
        if details_response.status_code != 200:
            await query.message.reply_text(
                f"‚ùå Error fetching peer details: {details_response.text}",
                parse_mode="Markdown"
            )
            return

        qr_response = requests.get(
            f"{API_BASE_URL}/api/qr-code",
            params={"peerName": peer_name, "config": f"{selected_interface}.conf"},
            timeout=5
        )
        if qr_response.status_code != 200:
            await query.message.reply_text(
                f"‚ùå Error fetching QR code: {qr_response.text}",
                parse_mode="Markdown"
            )
            return

        qr_data = qr_response.json().get("qr_code")
        if not qr_data:
            await query.message.reply_text(
                "‚ùå QR Code data not found.",
                parse_mode="Markdown"
            )
            return

        qr_image_data = base64.b64decode(qr_data.split(",")[1])
        qr_image = Image.open(BytesIO(qr_image_data))

        template_path = "static/images/template.jpg"
        template_image = Image.open(template_path).convert("RGB")
        template_image = template_image.resize((430, 500))

        draw = ImageDraw.Draw(template_image)

        box_xy = (20, 360, 420, 480)
        draw_rounded_rectangle(draw, box_xy, radius=20, fill="gray", outline="white", outline_width=2)

        qr_image = qr_image.resize((90, 90))
        qr_x, qr_y = 30, 374
        template_image.paste(qr_image, (qr_x, qr_y))

        font_path = "static/fonts/Poppins-Regular.ttf"
        try:
            font = ImageFont.truetype(font_path, 16)
        except IOError:
            font = ImageFont.load_default()

        text_x, text_y = 130, 375 
        line_height = 20
        draw.text((text_x, text_y), f"Peer Name: {peer_name}", font=font, fill="white")
        draw.text((text_x, text_y + line_height), f"Peer IP: {peer_ip}", font=font, fill="white")
        draw.text((text_x, text_y + line_height * 2), f"Data Limit: {data_limit}", font=font, fill="white")
        draw.text((text_x, text_y + line_height * 3), f"Expiry: {expiry}", font=font, fill="white")

        with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as temp_file:
            output_path = temp_file.name
            template_image.save(output_path, "JPEG", quality=95)

        await context.bot.send_photo(
            chat_id=query.message.chat_id,
            photo=open(output_path, "rb"),
            caption = f"üéâ ŸÇÿßŸÑÿ® ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ±: {peer_name} ({peer_ip}) ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ."
        )

        os.remove(output_path)

    except Exception as e:
        await query.message.reply_text(
            f"‚ùå Error generating template: {str(e)}",
            parse_mode="Markdown"
        )
        return

    keyboard = [
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(
        "‚úÖ ŸÇÿßŸÑÿ® ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ. ⁄ÜŸá ⁄©ÿßÿ± ÿØ€å⁄Øÿ±€å ŸÖ€åÿÆŸàÿßŸá€åÿØ ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØ ÿü",
        reply_markup=reply_markup
    )


async def peername_search(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    context.user_data["search_peer_name"] = peer_name
    response = await api_stuff("api/get-interfaces")

    if "error" in response:
        await update.message.reply_text(
            f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿáÿß:* `{response['error']}`",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    interfaces = response.get("interfaces", [])
    if not interfaces:
        await update.message.reply_text(
            "‚ùå *Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton(f"üåê {interface}", callback_data=f"select_interface_{interface}")]
        for interface in interfaces
    ]
    keyboard.append([InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "üåê *ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    return SELECT_INTERFACE


async def interface_select(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_interface = query.data.replace("select_interface_", "")
    context.user_data["selected_interface"] = selected_interface
    config_file = f"{selected_interface}.conf"
    context.user_data["selected_config"] = config_file

    peer_name = context.user_data.get("search_peer_name", "").strip()

    if not peer_name:
        await query.message.reply_text("‚ùå *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ±ÿß€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà Ÿàÿßÿ±ÿØ ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™.*", parse_mode="Markdown")
        return ConversationHandler.END

    response = await api_stuff(f"api/peers-by-interface?interface={selected_interface}")

    if "error" in response:
        await query.message.reply_text(
            f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ:* `{response['error']}`",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    peers = response.get("peers", [])

    matched_peers = [
        peer for peer in peers if peer["peer_name"].lower() == peer_name.lower()
    ]

    if not matched_peers:
        await query.message.reply_text(
            f"‚ùå *Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß ŸÜÿßŸÖ:* `{peer_name}` *Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.*",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    matched_peer = matched_peers[0] 
    context.user_data["peer_name"] = matched_peer["peer_name"]

    peer_details = (
        f"üî∑ **ÿ¨ÿ≤ÿ¶€åÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±**\n\n"
        f"üìõ **ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:** `{matched_peer['peer_name']}`\n"
        f"üåê **ÿ¢€å‚ÄåŸæ€å ⁄©ÿßÿ±ÿ®ÿ±:** `{matched_peer['peer_ip']}`\n"
        f"üîë **⁄©ŸÑ€åÿØ ÿπŸÖŸàŸÖ€å:** `{matched_peer['public_key']}`\n"
        f"‚ö° **Ÿàÿ∂ÿπ€åÿ™:** {'üü¢ ŸÅÿπÿßŸÑ' if not matched_peer['expiry_blocked'] else 'üî¥ ŸÖÿ≥ÿØŸàÿØ'}\n"
    )
    keyboard = [
        [InlineKeyboardButton("üìÑ ÿØÿßŸÜŸÑŸàÿØ ÿ™ŸÜÿ∏€åŸÖÿßÿ™", callback_data=f"download_create_{matched_peer['peer_name']}")],
        [InlineKeyboardButton("üì∑ ÿ™ŸàŸÑ€åÿØ ⁄©ÿØ QR", callback_data=f"qr_create_{matched_peer['peer_name']}")],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿßŸÜÿ™ÿÆÿßÿ® ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥", callback_data="download_qr_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(peer_details, reply_markup=reply_markup, parse_mode="Markdown")

    return ConversationHandler.END


async def peer_decision(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    action, peer_name = query.data.split("_", 1)
    context.user_data["peer_name"] = peer_name  

    if action == "download":
        await download_peerconfig_create(update, context)
    elif action == "qr":
        await generate_peerqr_create(update, context)



async def download_peerconfig_general(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    data_parts = query.data.split("_")
    if len(data_parts) < 3:
        await query.message.reply_text("‚ùå ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßŸÅ€å ÿ®ÿ±ÿß€å ÿØÿßŸÜŸÑŸàÿØ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.", parse_mode="Markdown")
        return

    peer_name = "_".join(data_parts[2:])
    config_file = context.user_data.get("selected_config")

    if not config_file or not config_file.endswith(".conf"):
        await query.message.reply_text("‚ùå ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ŸÅÿ±ÿ¢€åŸÜÿØ ÿ±ÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ¢ÿ∫ÿßÿ≤ ⁄©ŸÜ€åÿØ.")
        return

    expiry_days = context.user_data.get("expiry_days", 1)
    data_limit = context.user_data.get("data_limit", "N/A")

    tehran_tz = timezone("Asia/Tehran")
    now_tehran = datetime.now(tehran_tz).date()

    current_jalali_date = jdate.fromgregorian(date=now_tehran)
    expiry_date_jalali = current_jalali_date + timedelta(days=expiry_days)
    expiry_date_jalali_str = f"{expiry_date_jalali.year}/{expiry_date_jalali.month:02}/{expiry_date_jalali.day:02}"

    config_url = f"{API_BASE_URL}/api/download-peer-config?peerName={peer_name}&config={config_file}"
    short_link_url = f"{API_BASE_URL}/api/get-peer-link?peerName={peer_name}&config={config_file}"

    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(short_link_url, headers={"Authorization": f"Bearer {API_KEY}"}) as link_response:
                short_link = "N/A"
                if link_response.status == 200:
                    link_data = await link_response.json()
                    short_link = link_data.get("short_link", "N/A")
                else:
                    print(f"Couldn't retrieve short link. Status: {link_response.status}")

            async with session.get(config_url, headers={"Authorization": f"Bearer {API_KEY}"}) as config_response:
                if config_response.status == 200:
                    peer_config = await config_response.text()

                    keyboard = [
                        [
                            InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà", callback_data="main_menu"),
                            InlineKeyboardButton("üìã ŸÑ€åÿ≥ÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu"),
                        ]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)

                    caption = (
                        f"ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿ±ÿß€å {peer_name}\n\n"
                        f"üë§ *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å:* {peer_name}\n"
                        f"‚è≥ *ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß:* {expiry_days} ÿ±Ÿàÿ≤\n"
                        f"üìÖ *ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß (ÿ¥ŸÖÿ≥€å):* {expiry_date_jalali_str}\n"
                        f"üìè *ŸÖ€åÿ≤ÿßŸÜ ÿ≠ÿ¨ŸÖ:* {data_limit}\n\n"
                        f"üîó *ŸÑ€åŸÜ⁄© ⁄©Ÿàÿ™ÿßŸá ⁄©ÿßŸÜŸÅ€å⁄Ø:*\n"
                        f"[{short_link}]({short_link})\n\n"
                        f"üìÑ *ŸÖÿ≠ÿ™Ÿàÿß€å ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™:*\n"
                        f"```\n{peer_config}\n```"
                    )

                    await context.bot.send_document(
                        chat_id=query.message.chat_id,
                        document=BytesIO(peer_config.encode("utf-8")),
                        filename=f"{peer_name}.conf",
                        caption=caption,
                        parse_mode="Markdown",
                        reply_markup=reply_markup
                    )
                else:
                    error = await config_response.json()
                    await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {error.get('error', 'ÿπÿØŸÖ ÿ™ŸàÿßŸÜÿß€å€å ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™')}")
        except Exception as e:
            await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {str(e)}")


async def generate_peerqr_general(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    data_parts = query.data.split("_")
    if len(data_parts) < 3:
        await query.message.reply_text("‚ùå ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßŸÅ€å ÿ®ÿ±ÿß€å ÿØÿ±€åÿßŸÅÿ™ QR Code Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.", parse_mode="Markdown")
        return

    peer_name = "_".join(data_parts[2:])
    config_file = context.user_data.get("selected_config")

    if not config_file or not config_file.endswith(".conf"):
        await query.message.reply_text("‚ùå ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ŸÅÿ±ÿ¢€åŸÜÿØ ÿ±ÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ¢ÿ∫ÿßÿ≤ ⁄©ŸÜ€åÿØ.")
        return

    expiry_days = context.user_data.get("expiry_days", 1)
    data_limit = context.user_data.get("data_limit", "N/A")

    tehran_tz = timezone("Asia/Tehran")
    now_tehran = datetime.now(tehran_tz).date()

    current_jalali_date = jdate.fromgregorian(date=now_tehran)
    expiry_date_jalali = current_jalali_date + timedelta(days=expiry_days)
    expiry_date_jalali_str = f"{expiry_date_jalali.year}/{expiry_date_jalali.month:02}/{expiry_date_jalali.day:02}"

    qr_url = f"{API_BASE_URL}/api/download-peer-qr?peerName={peer_name}&config={config_file}"
    config_url = f"{API_BASE_URL}/api/download-peer-config?peerName={peer_name}&config={config_file}"
    short_link_url = f"{API_BASE_URL}/api/get-peer-link?peerName={peer_name}&config={config_file}"

    async with aiohttp.ClientSession() as session:
        try:
            short_link = "N/A"
            async with session.get(short_link_url, headers={"Authorization": f"Bearer {API_KEY}"}) as link_response:
                if link_response.status == 200:
                    link_data = await link_response.json()
                    short_link = link_data.get("short_link", "N/A")
                else:
                    print(f"Couldn't retrieve short link. Status: {link_response.status}")

            async with session.get(qr_url, headers={"Authorization": f"Bearer {API_KEY}"}) as qr_response:
                if qr_response.status == 200:
                    qr_image = await qr_response.read()
                else:
                    error = await qr_response.json()
                    await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ QR Code: {error.get('error', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}")
                    return

            peer_config = "N/A"
            async with session.get(config_url, headers={"Authorization": f"Bearer {API_KEY}"}) as config_response:
                if config_response.status == 200:
                    peer_config = await config_response.text()
                else:
                    error = await config_response.json()
                    await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿ™ŸÜÿ∏€åŸÖÿßÿ™: {error.get('error', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}")
                    return

            caption = (
                f"ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿ±ÿß€å {peer_name}\n\n"
                f"üë§ *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å:* {peer_name}\n"
                f"‚è≥ *ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß:* {expiry_days} ÿ±Ÿàÿ≤\n"
                f"üìÖ *ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß (ÿ¥ŸÖÿ≥€å):* {expiry_date_jalali_str}\n"
                f"üìè *ŸÖ€åÿ≤ÿßŸÜ ÿ≠ÿ¨ŸÖ:* {data_limit}\n\n"
                f"üîó *ŸÑ€åŸÜ⁄© ⁄©Ÿàÿ™ÿßŸá ⁄©ÿßŸÜŸÅ€å⁄Ø:*\n"
                f"[{short_link}]({short_link})\n\n"
                f"ÿ®ÿ±ÿß€å ⁄©Ÿæ€å ⁄©ÿ±ÿØŸÜ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ÿå ÿßÿ≤ ŸÖÿ™ŸÜ ÿ≤€åÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:\n"
                f"```\n{peer_config}\n```"
            )

            keyboard = [
                [
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu"),
                    InlineKeyboardButton("üìã ŸÑ€åÿ≥ÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu"),
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await context.bot.send_photo(
                chat_id=query.message.chat_id,
                photo=BytesIO(qr_image),
                caption=caption,
                parse_mode="Markdown",
                reply_markup=reply_markup
            )
        except Exception as e:
            await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {str(e)}")


async def init_deletepeer(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    response = await api_stuff("api/get-interfaces")
    
    if "error" in response:
        await context.bot.send_message(chat_id, f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥‚ÄåŸáÿß: `{response['error']}`", parse_mode="Markdown")
        return ConversationHandler.END

    interfaces = response.get("interfaces", [])
    if not interfaces:
        await context.bot.send_message(chat_id, "‚ùå *Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*", parse_mode="Markdown")
        return ConversationHandler.END

    keyboard = [[InlineKeyboardButton(f"üìÇ {interface}", callback_data=f"peer_interface_{interface}")]
                for interface in interfaces]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(
        chat_id,
        "üåê *ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ÿ≠ÿ∞ŸÅ ⁄©ÿßÿ±ÿ®ÿ± ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    return CHOOSE_WG_INTERFACE



async def select_interface_delete(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_interface = query.data.replace("peer_interface_", "") + ".conf"
    context.user_data["selected_interface"] = selected_interface

    await query.message.reply_text(
        "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ≠ÿ∞ŸÅ ⁄©ŸÜ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:* (ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÜ⁄©ŸÜ€åÿØ)\n\n"
        "ŸÖÿ´ÿßŸÑ: `azumi`",
        parse_mode="Markdown"
    )
    return ENTER_PEER_NAME

async def specify_peername_delete(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    if not re.match(r"^[a-zA-Z0-9_-]+$", peer_name): 
        await update.message.reply_text(
            "‚ùå ŸÅÿ±ŸÖÿ™ ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿßÿ¥ÿ™ÿ®ÿßŸá ÿßÿ≥ÿ™ÿå ŸÅŸÇÿ∑ ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ Ÿà ÿßÿπÿØÿßÿØ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ."
        )
        return ENTER_PEER_NAME

    context.user_data["peer_name"] = peer_name

    selected_interface = context.user_data["selected_interface"]

    response = await api_stuff(f"api/get-peer-info?peerName={peer_name}&configFile={selected_interface}")
    if "error" in response:
        await update.message.reply_text(
            f"‚ùå ÿÆÿ∑ÿß: `{response['error']}`\n\nŸÑÿ∑ŸÅÿßŸã ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ÿ≠ÿßÿµŸÑ ⁄©ŸÜ€åÿØ ⁄©Ÿá ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± `{selected_interface}` Ÿàÿ¨ŸàÿØ ÿØÿßÿ±ÿØ.",
            parse_mode="Markdown"
        )
        return ENTER_PEER_NAME

    peer_info = response.get("peerInfo", {})
    context.user_data["peer_info"] = peer_info

    keyboard = [[InlineKeyboardButton("üóëÔ∏è ÿ≠ÿ∞ŸÅ ⁄©ÿßÿ±ÿ®ÿ±", callback_data="peer_confirm_delete")],
                [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿßŸÜÿ™ÿÆÿßÿ® ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥", callback_data="peer_back_to_interface")]]
    await update.message.reply_text(
        f"üë§ *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:* `{peer_name}`\n"
        f"üåç *ÿ¢ÿØÿ±ÿ≥ IP:* `{peer_info.get('peer_ip', 'Unknown')}`\n"
        f"üìÑ *ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™:* `{selected_interface}`\n\n"
        "‚ö†Ô∏è *ÿ¢€åÿß ŸÖÿ∑ŸÖÿ¶ŸÜ Ÿáÿ≥ÿ™€åÿØ ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ≠ÿ∞ŸÅ ⁄©ŸÜ€åÿØÿü*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return CONFIRM_PEER_DELETION



async def apply_peer_deletion(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    if query.data == "peer_confirm_delete":
        peer_name = context.user_data["peer_name"]
        selected_interface = context.user_data["selected_interface"]

        payload = {"peerName": peer_name, "configFile": selected_interface}
        response = await api_stuff("api/delete-peer", method="POST", data=payload)
        if "error" in response:
            await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: `{response['error']}`", parse_mode="Markdown")
            return ConversationHandler.END

        keyboard = [
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß", callback_data="peers_menu")],
            [InlineKeyboardButton("üè† ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.message.reply_text(
            f"‚úÖ *⁄©ÿßÿ±ÿ®ÿ±'{peer_name}' ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ!*\n\n"
            f"üìÑ ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™: `{selected_interface}`",
            parse_mode="Markdown",
            reply_markup=reply_markup
        )
    elif query.data == "peer_back_to_interface":
        return await init_deletepeer(update, context)

    return ConversationHandler.END


async def download_peerconfig_create(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    data_parts = query.data.split("_")
    if len(data_parts) < 3:
        await query.message.reply_text("‚ùå ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßŸÅ€å ÿ®ÿ±ÿß€å ÿØÿßŸÜŸÑŸàÿØ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.", parse_mode="Markdown")
        return

    peer_name = "_".join(data_parts[2:])
    config_file = context.user_data.get("selected_config")

    if not config_file or not config_file.endswith(".conf"):
        await query.message.reply_text("‚ùå ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ŸÅÿ±ÿ¢€åŸÜÿØ ÿ±ÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ¢ÿ∫ÿßÿ≤ ⁄©ŸÜ€åÿØ.")
        return

    short_link = "N/A" 

    peer_details_url = f"{API_BASE_URL}/api/bot-peer-details-fa?peerName={peer_name}&configName={config_file}"

    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(peer_details_url, headers={"Authorization": f"Bearer {API_KEY}"}) as details_response:
                if details_response.status == 200:
                    details_data = await details_response.json()

                    data_limit = details_data.get("limit", "N/A")
                    used_data = details_data.get("used", 0)
                    remaining_data = details_data.get("remaining", "N/A")
                    expiry_date_human = details_data.get("expiry_human", "N/A") 
                    expiry_date = details_data.get("expiry", "N/A")

                    print(f"Fetched peer details: Limit: {data_limit}, Used: {used_data}, Remaining: {remaining_data}, Expiry: {expiry_date}")

                else:
                    await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {details_response.get('error', 'ÿπÿØŸÖ ÿ™ŸàÿßŸÜÿß€å€å ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿ¨ÿ≤ÿ¶€åÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±')}")

            short_link_url = f"{API_BASE_URL}/api/get-peer-link?peerName={peer_name}&config={config_file}"
            async with session.get(short_link_url, headers={"Authorization": f"Bearer {API_KEY}"}) as link_response:
                if link_response.status == 200:
                    link_data = await link_response.json()
                    short_link = link_data.get("short_link", "N/A")
                else:
                    print(f"Couldn't retrieve short link. Status: {link_response.status}")

            config_url = f"{API_BASE_URL}/api/download-peer-config?peerName={peer_name}&config={config_file}"
            async with session.get(config_url, headers={"Authorization": f"Bearer {API_KEY}"}) as config_response:
                if config_response.status == 200:
                    peer_config = await config_response.text()

                    keyboard = [
                        [
                            InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà", callback_data="main_menu"),
                            InlineKeyboardButton("üìã ŸÑ€åÿ≥ÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu"),
                        ]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)

                    caption = (
                        f"ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿ±ÿß€å {peer_name}\n\n"
                        f"üë§ *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å:* {peer_name}\n"
                        f"‚è≥ *ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß:* {expiry_date_human}\n"
                        f"üìè *ŸÖ€åÿ≤ÿßŸÜ ÿ≠ÿ¨ŸÖ:* {data_limit}\n"
                        f"üìâ *ÿ≠ÿ¨ŸÖ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¥ÿØŸá:* {used_data} B\n"
                        f"üì• *ÿ≠ÿ¨ŸÖ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá:* {remaining_data} B\n\n"
                        f"üîó * ŸÑ€åŸÜ⁄© ⁄©Ÿàÿ™ÿßŸá ⁄©ÿßŸÜŸÅ€å⁄Ø:*\n"
                        f"[{short_link}]({short_link})\n\n"
                        f"üìÑ *ŸÖÿ≠ÿ™Ÿàÿß€å ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™:*\n"
                        f"```\n{peer_config}\n```"
                    )

                    await context.bot.send_document(
                        chat_id=query.message.chat_id,
                        document=BytesIO(peer_config.encode("utf-8")),
                        filename=f"{peer_name}.conf",
                        caption=caption,
                        parse_mode="Markdown",
                        reply_markup=reply_markup
                    )
                else:
                    error = await config_response.json()
                    await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {error.get('error', 'ÿπÿØŸÖ ÿ™ŸàÿßŸÜÿß€å€å ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™')}")
        except Exception as e:
            await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {str(e)}")

            




async def generate_peerqr_create(update, context):
    query = update.callback_query
    await query.answer()

    peer_name = query.data.replace("qr_create_", "").strip()

    selected_interface = context.user_data.get("selected_interface", "wg0")
    config_file = f"{selected_interface}.conf"

    if not config_file or not config_file.endswith(".conf"):
        await query.message.reply_text("‚ùå ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ŸÅÿ±ÿ¢€åŸÜÿØ ÿ±ÿß ÿØŸàÿ®ÿßÿ±Ÿá ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ.")
        return

    qr_url = f"{API_BASE_URL}/api/download-peer-qr?peerName={peer_name}&config={config_file}"
    config_url = f"{API_BASE_URL}/api/download-peer-config?peerName={peer_name}&config={config_file}"
    short_link_url = f"{API_BASE_URL}/api/get-peer-link?peerName={peer_name}&config={config_file}"
    peer_details_url = f"{API_BASE_URL}/api/bot-peer-details-fa?peerName={peer_name}&configName={config_file}"

    async with aiohttp.ClientSession() as session:
        try:
            data_limit, used_data, remaining_data, expiry_date_human, expiry_date = "N/A", 0, "N/A", "N/A", "N/A"

            async with session.get(peer_details_url, headers={"Authorization": f"Bearer {API_KEY}"}) as details_response:
                if details_response.status == 200:
                    details_data = await details_response.json()
                    data_limit = details_data.get("limit", "N/A")
                    used_data = details_data.get("used", 0)
                    remaining_data = details_data.get("remaining", "N/A")
                    expiry_date_human = details_data.get("expiry_human", "N/A") 
                    expiry_date = details_data.get("expiry", "N/A")
                else:
                    print(f"Couldn't retrieve peer details. Status: {details_response.status}")

            short_link = "N/A"
            async with session.get(short_link_url, headers={"Authorization": f"Bearer {API_KEY}"}) as link_response:
                if link_response.status == 200:
                    link_data = await link_response.json()
                    short_link = link_data.get("short_link", "N/A")
                else:
                    print(f"Couldn't retrieve short link. Status: {link_response.status}")

            async with session.get(qr_url, headers={"Authorization": f"Bearer {API_KEY}"}) as qr_response:
                if qr_response.status == 200:
                    qr_image = await qr_response.read()
                else:
                    error = await qr_response.json()
                    await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ QR Code: {error.get('error', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}")
                    return

            async with session.get(config_url, headers={"Authorization": f"Bearer {API_KEY}"}) as config_response:
                if config_response.status == 200:
                    peer_config = await config_response.text()
                else:
                    error = await config_response.json()
                    await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿ™ŸÜÿ∏€åŸÖÿßÿ™: {error.get('error', 'ŸÜÿßŸÖÿ¥ÿÆÿµ')}")
                    return

            caption = (
                f"üì∑ ⁄©ÿØ QR ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± `{peer_name}`\n\n"
                f"üîó *ŸÑ€åŸÜ⁄© ⁄©Ÿàÿ™ÿßŸá ⁄©ÿßŸÜŸÅ€å⁄Ø:*\n"
                f"[{short_link}]({short_link})\n\n"
                f"üë§ *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å:* {peer_name}\n"
                f"‚è≥ *ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß:* {expiry_date_human}\n"
                f"üìè *ŸÖ€åÿ≤ÿßŸÜ ÿ≠ÿ¨ŸÖ:* {data_limit}\n"
                f"üìâ *ÿ≠ÿ¨ŸÖ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¥ÿØŸá:* {used_data} B\n"
                f"üì• *ÿ≠ÿ¨ŸÖ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá:* {remaining_data} B\n\n"
                f"ÿ®ÿ±ÿß€å ⁄©Ÿæ€å ⁄©ÿ±ÿØŸÜ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ÿå ÿßÿ≤ ŸÖÿ™ŸÜ ÿ≤€åÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:\n"
                f"```\n{peer_config}\n```"
            )

            keyboard = [
                [
                    InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu"),
                    InlineKeyboardButton("üìã ŸÑ€åÿ≥ÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu"),
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await context.bot.send_photo(
                chat_id=query.message.chat_id,
                photo=BytesIO(qr_image),
                caption=caption,
                parse_mode="Markdown",
                reply_markup=reply_markup
            )
        except Exception as e:
            await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {str(e)}")



async def init_peer_create(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå ÿ¥ŸÖÿß ŸÖÿ¨ÿßÿ≤ ÿ®Ÿá ÿßŸÜÿ¨ÿßŸÖ ÿß€åŸÜ ÿπŸÖŸÑ€åÿßÿ™ ŸÜ€åÿ≥ÿ™€åÿØ.",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("‚ûï ÿß€åÿ¨ÿßÿØ €å⁄© ⁄©ÿßÿ±ÿ®ÿ±", callback_data="mode_single")],
        [InlineKeyboardButton("‚ûï‚ûï ÿß€åÿ¨ÿßÿØ ⁄ÜŸÜÿØ ⁄©ÿßÿ±ÿ®ÿ± (Bulk)", callback_data="mode_bulk")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await context.bot.send_message(
        chat_id,
        "üìã *ÿßŸÜÿ™ÿÆÿßÿ® ÿ≠ÿßŸÑÿ™ ÿß€åÿ¨ÿßÿØ ⁄©ÿßÿ±ÿ®ÿ±:*",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    return SELECT_MODE

async def select_mode(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    mode = query.data.replace("mode_", "")
    context.user_data["creation_mode"] = mode  

    response = await api_stuff("api/get-interfaces")
    
    if "error" in response:
        await context.bot.send_message(chat_id=query.message.chat_id, 
                                       text=f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥‚ÄåŸáÿß:* {response['error']}",
                                       parse_mode="Markdown")
        return ConversationHandler.END

    interfaces = response.get("interfaces", [])
    if not interfaces:
        await context.bot.send_message(chat_id=query.message.chat_id, 
                                       text="‚ùå *Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*",
                                       parse_mode="Markdown")
        return ConversationHandler.END

    keyboard = [[InlineKeyboardButton(f"üìÇ {interface}", callback_data=f"config_{interface}")]
                for interface in interfaces]
    await query.message.reply_text(
        "üåê *€å⁄© ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return SELECT_CONFIG

async def select_config(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_config = query.data.replace("config_", "") + ".conf"
    context.user_data["selected_config"] = selected_config

    response = await api_stuff(f"api/available-ips?config={selected_config}")
    if "error" in response:
        await query.message.reply_text(f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ŸÑ€åÿ≥ÿ™ ÿ¢€å‚ÄåŸæ€å‚ÄåŸáÿß€å ŸÖŸàÿ¨ŸàÿØ:* {response['error']}", parse_mode="Markdown")
        return ConversationHandler.END

    available_ips = response.get("availableIps", [])[:5]
    if not available_ips:
        await query.message.reply_text("‚ùå *Ÿá€å⁄Ü ÿ¢€å‚ÄåŸæ€å ŸÖŸàÿ¨ŸàÿØ€å ÿ®ÿ±ÿß€å ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿßŸÜÿ™ÿÆÿßÿ®€å Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.*", parse_mode="Markdown")
        return ConversationHandler.END

    keyboard = [[InlineKeyboardButton(f"üåê {ip}", callback_data=f"ip_{ip}")] for ip in available_ips]
    await query.message.reply_text(
        "üõ† *ÿ¢ÿØÿ±ÿ≥ ÿ¢€å‚ÄåŸæ€å ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ®ÿ±ÿß€å ÿß€åÿ¨ÿßÿØ Ÿæ€åÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return SELECT_IP_ADDRESS

async def choose_ip(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_ip = query.data.replace("ip_", "")
    context.user_data["selected_ip"] = selected_ip

    mode = context.user_data.get("creation_mode", "single")
    if mode == "bulk":
        await query.message.reply_text(
            "üìä *ÿ™ÿπÿØÿßÿØ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ®ÿ±ÿß€å ÿß€åÿ¨ÿßÿØ (ÿ≠ÿØÿß⁄©ÿ´ÿ± 50):*\n\n"
            "ŸÖÿ´ÿßŸÑ: `5`",
            parse_mode="Markdown"
        )
        return INPUT_BULK_COUNT
    else:
        await query.message.reply_text(
            "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:* (ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÜ⁄©ŸÜ€åÿØ)\n\n"
            "ŸÖÿ´ÿßŸÑ: `azumi`",
            parse_mode="Markdown"
        )
        return INPUT_PEER_NAME

async def write_bulk_count(update: Update, context: CallbackContext):
    count_text = update.message.text.strip()
    if not count_text.isdigit() or not (1 <= int(count_text) <= 50):
        await update.message.reply_text("‚ùå ŸÖŸÇÿØÿßÿ± ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿπÿØÿØ ÿ®€åŸÜ 1 ÿ™ÿß 50 Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return INPUT_BULK_COUNT

    context.user_data["bulk_count"] = int(count_text)
    await update.message.reply_text(
        "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:* (ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÜ⁄©ŸÜ€åÿØ)\n\n"
        "ŸÖÿ´ÿßŸÑ: `azumi`",
        parse_mode="Markdown"
    )
    return INPUT_PEER_NAME

async def input_peer_name(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    if not re.match(r"^[a-zA-Z0-9_-]+$", peer_name):
        await update.message.reply_text("‚ùå ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÅŸÇÿ∑ ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ Ÿà ÿßÿπÿØÿßÿØ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.")
        return INPUT_PEER_NAME

    context.user_data["peer_name"] = peer_name

    keyboard = [[InlineKeyboardButton("üßÆ MiB", callback_data="unit_MiB")],
                [InlineKeyboardButton("üìä GiB", callback_data="unit_GiB")]]
    await update.message.reply_text(
        "üìê *Ÿàÿßÿ≠ÿØ ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return SELECT_LIMIT_UNIT

async def choose_limit_unit(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    context.user_data["limit_unit"] = query.data.replace("unit_", "")

    await query.message.reply_text(
        "üìè *ŸÖŸÇÿØÿßÿ± ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:*\n\n"
        "ŸÖÿ´ÿßŸÑ: `500`",
        parse_mode="Markdown"
    )
    return INPUT_LIMIT_VALUE

async def choose_limit_value(update: Update, context: CallbackContext):
    value = update.message.text.strip()
    if not value.isdigit() or not (0 < int(value) <= 1024):
        await update.message.reply_text("‚ùå ŸÖŸÇÿØÿßÿ± ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿπÿØÿØ€å ÿ®€åŸÜ 1 ÿ™ÿß 1024 Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return INPUT_LIMIT_VALUE

    context.user_data["data_limit"] = f"{value}{context.user_data['limit_unit']}"

    keyboard = [[InlineKeyboardButton("üåç 1.1.1.1", callback_data="dns_1.1.1.1")],
                [InlineKeyboardButton("üåé 8.8.8.8", callback_data="dns_8.8.8.8")],
                [InlineKeyboardButton("‚úèÔ∏è ÿ≥ŸÅÿßÿ±ÿ¥€å", callback_data="dns_custom")]]
    await update.message.reply_text(
        "üåê *€å⁄© DNS ÿ≥ÿ±Ÿàÿ± ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ⁄Øÿ≤€åŸÜŸá ÿ≥ŸÅÿßÿ±ÿ¥€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return SELECT_DNS

async def select_dns(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    if query.data == "dns_custom":
        await query.message.reply_text(
            "‚úèÔ∏è *ÿ¢ÿØÿ±ÿ≥‚ÄåŸáÿß€å DNS ⁄©ÿßÿ≥ÿ™ŸàŸÖ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (ÿ®ÿß ⁄©ÿßŸÖÿß ÿ¨ÿØÿß ⁄©ŸÜ€åÿØ):*\n\n"
            "ŸÖÿ´ÿßŸÑ: `8.8.8.8,1.1.1.1`",
            parse_mode="Markdown"
        )
        return INPUT_CUSTOM_DNS

    context.user_data["dns"] = query.data.replace("dns_", "")
    await query.message.reply_text(
        "‚è≥ *ÿ™ÿπÿØÿßÿØ ÿ±Ÿàÿ≤‚ÄåŸáÿß:* (ŸÖÿ´ÿßŸÑ: `10`)",
        parse_mode="Markdown"
    )
    return INPUT_EXPIRY_DAYS

async def write_custom_dns(update: Update, context: CallbackContext):
    dns = update.message.text.strip()
    if not all(
        re.match(r"^\d{1,3}(\.\d{1,3}){3}$", entry) or re.match(r"^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", entry)
        for entry in dns.split(",")
    ):
        await update.message.reply_text("‚ùå ŸÅÿ±ŸÖÿ™ DNS ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿ¢ÿØÿ±ÿ≥‚ÄåŸáÿß€å IP ŸÖÿπÿ™ÿ®ÿ± €åÿß ŸÜÿßŸÖ ÿØÿßŸÖŸÜŸá Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return INPUT_CUSTOM_DNS

    context.user_data["dns"] = dns
    await update.message.reply_text(
        "‚è≥ *ÿ™ÿπÿØÿßÿØ ÿ±Ÿàÿ≤‚ÄåŸáÿß:* (ŸÖÿ´ÿßŸÑ: `10`)",
        parse_mode="Markdown"
    )
    return INPUT_EXPIRY_DAYS

async def write_expiry_days(update: Update, context: CallbackContext):
    days_text = update.message.text.strip()
    if not days_text.isdigit() or int(days_text) < 0:
        await update.message.reply_text("‚ùå ŸÖŸÇÿØÿßÿ± ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿπÿØÿØ ÿ∫€åÿ±ŸÖŸÜŸÅ€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return INPUT_EXPIRY_DAYS

    context.user_data["expiry_days"] = int(days_text)
    
    await update.message.reply_text(
        "‚è≥ *ŸÖŸÇÿØÿßÿ± MTU ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (ÿßÿÆÿ™€åÿßÿ±€åÿå Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂: `1280`):*\n\n"
        "ŸÖÿ´ÿßŸÑ: `1400`",
        parse_mode="Markdown"
    )
    return INPUT_MTU

async def write_mtu(update: Update, context: CallbackContext):
    mtu_value = update.message.text.strip()

    if mtu_value and not mtu_value.isdigit():
        await update.message.reply_text("‚ùå ŸÖŸÇÿØÿßÿ± MTU ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿπÿØÿØ€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return INPUT_MTU

    context.user_data["mtu"] = int(mtu_value) if mtu_value else 1280

    await update.message.reply_text(
        "‚è≥ *ŸÖŸÇÿØÿßÿ± Persistent Keepalive ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂: `25`):*\n\n"
        "ŸÖÿ´ÿßŸÑ: `25`",
        parse_mode="Markdown"
    )
    return INPUT_KEEPALIVE

async def write_keepalive(update: Update, context: CallbackContext):
    keepalive_value = update.message.text.strip()
    if keepalive_value and not keepalive_value.isdigit():
        await update.message.reply_text("‚ùå ŸÖŸÇÿØÿßÿ± Persistent Keepalive ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿπÿØÿØ€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return INPUT_KEEPALIVE

    context.user_data["persistent_keepalive"] = int(keepalive_value) if keepalive_value else 25

    keyboard = [
        [InlineKeyboardButton("‚úÖ ÿ®ŸÑŸá", callback_data="confirm_usage_yes")],
        [InlineKeyboardButton("‚ùå ÿÆ€åÿ±", callback_data="confirm_usage_no")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "üü¢ *ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ 'ÿ¥ÿ±Ÿàÿπ ÿ™ÿßÿ±€åÿÆ Ÿæÿ≥ ÿßÿ≤ ÿßÿ™ÿµÿßŸÑ ÿßŸàŸÑ'ÿü*\n\n"
        "€å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ÿ≤€åÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    return CONFIRM_USAGE

async def confirm_use(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    first_usage = query.data == "confirm_usage_yes"
    context.user_data["first_usage"] = first_usage

    mtu = context.user_data.get("mtu", 1280)
    persistent_keepalive = context.user_data.get("persistent_keepalive", 25)

    expiry_days = context.user_data.get("expiry_days", 0)

    payload = {
        "peerName": context.user_data["peer_name"],
        "peerIp": context.user_data["selected_ip"],
        "dataLimit": context.user_data["data_limit"],
        "configFile": context.user_data["selected_config"],
        "dns": context.user_data["dns"],
        "expiryDays": expiry_days,
        "firstUsage": first_usage,
        "persistentKeepalive": persistent_keepalive,
        "mtu": mtu
    }

    creation_mode = context.user_data.get("creation_mode", "single")
    if creation_mode == "bulk":
        payload["bulkCount"] = context.user_data.get("bulk_count", 1)

    response = await api_stuff("api/create-peer", method="POST", data=payload)
    if "error" in response:
        await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß: {response['error']}", parse_mode="Markdown")
        return ConversationHandler.END

    if creation_mode == "single":
        peer_name = response.get("peer_name", context.user_data["peer_name"])
        short_link = response.get("short_link", "N/A")

        keyboard = [
            [
                InlineKeyboardButton(
                    "üìÇ ÿØÿßŸÜŸÑŸàÿØ ÿ™ŸÜÿ∏€åŸÖÿßÿ™",
                    callback_data=f"download_general_{peer_name}"
                ),
                InlineKeyboardButton(
                    "üì∑ ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿØ QR",
                    callback_data=f"qr_general_{peer_name}"
                )
            ],
            [
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu"),
                InlineKeyboardButton("üè† ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")
            ]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.message.reply_text(
            f"‚úÖ *⁄©ÿßÿ±ÿ®ÿ± '{peer_name}' ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ!* \n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üîπ *Peer Name:* {peer_name}\n"
            f"üìÇ *Config File Name:* {payload['configFile']}\n"
            f"üåê *IP Address:* {payload['peerIp']}\n"
            f"üìè *Data Limit:* {payload['dataLimit']}\n"
            f"‚è≥ *Expiry Time:* {expiry_days} days\n"
            f"üì° *MTU:* {payload['mtu']}\n"
            f"üõú *DNS:* {payload['dns']}\n"
            f"üü¢ *Start Date After First Connection:* {'Enabled üü¢' if first_usage else 'Disabled üî¥'}\n"
            f"üåê *Persistent Keepalive:* {persistent_keepalive}\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"ÿ®ÿ±ÿß€å ÿØÿßŸÜŸÑŸàÿØ ŸÅÿß€åŸÑ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ €åÿß ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿØ QRÿå ÿßÿ≤ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ≤€åÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:",
            parse_mode="Markdown",
            reply_markup=reply_markup
        )

    elif creation_mode == "bulk":
        peers = response.get("peers", [])
        if not peers:
            await query.message.reply_text("‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿß€åÿ¨ÿßÿØ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ®Ÿá ÿµŸàÿ±ÿ™ ⁄Øÿ±ŸàŸá€å.", parse_mode="Markdown")
            return ConversationHandler.END

        message = f"‚úÖ *{len(peers)} ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØŸÜÿØ!*"

        await query.message.reply_text(
            message,
            parse_mode="Markdown"
        )

        for peer in peers:
            peer_name = peer.get("peer_name")
            short_link = peer.get("short_link", "N/A")

            keyboard = [
                [
                    InlineKeyboardButton(
                        "üìÇ ÿØÿßŸÜŸÑŸàÿØ ÿ™ŸÜÿ∏€åŸÖÿßÿ™",
                        callback_data=f"download_general_{peer_name}"
                    ),
                    InlineKeyboardButton(
                        "üì∑ ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿØ QR",
                        callback_data=f"qr_general_{peer_name}"
                    )
                ]
            ]

            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.message.reply_text(
                f"üîπ *ŸÜÿßŸÖ Ÿæ€åÿ±Ÿá:* {peer_name}\n"
                f"üîó *ŸÑ€åŸÜ⁄© ⁄©Ÿàÿ™ÿßŸá ⁄©ÿßŸÜŸÅ€å⁄Ø:* [{short_link}]({short_link})",
                parse_mode="Markdown",
                reply_markup=reply_markup
            )

        navigation_keyboard = [
            [
                InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu"),
                InlineKeyboardButton("üè† ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")
            ]
        ]

        navigation_reply_markup = InlineKeyboardMarkup(navigation_keyboard)

        await query.message.reply_text(
            "üîÑ *ÿ®ÿ±ÿß€å ŸÖÿØ€åÿ±€åÿ™ ÿ®€åÿ¥ÿ™ÿ± ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜÿå ÿßÿ≤ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ≤€åÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:*",
            parse_mode="Markdown",
            reply_markup=navigation_reply_markup
        )

    return ConversationHandler.END





async def init_resetpeer(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    response = await api_stuff("api/get-interfaces")
    
    if "error" in response:
        await context.bot.send_message(chat_id, f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥‚ÄåŸáÿß: `{response['error']}`", parse_mode="Markdown")
        return ConversationHandler.END

    interfaces = response.get("interfaces", [])
    if not interfaces:
        await context.bot.send_message(chat_id, "‚ùå *Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*", parse_mode="Markdown")
        return ConversationHandler.END

    keyboard = [[InlineKeyboardButton(f"üìÇ {interface}", callback_data=f"reset_interface_{interface}")]
                for interface in interfaces]
    await context.bot.send_message(
        chat_id,
        "üåê *€å⁄© ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ÿ±€åÿ≥ÿ™ ÿ™ÿ±ÿßŸÅ€å⁄© €åÿß ÿßŸÜŸÇÿ∂ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return SELECT_RESET_INTERFACE


async def select_reset_interface(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_interface = query.data.replace("reset_interface_", "") + ".conf"
    context.user_data["selected_reset_interface"] = selected_interface

    await query.message.reply_text(
        "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ™ÿ±ÿßŸÅ€å⁄© €åÿß ÿßŸÜŸÇÿ∂ÿß€å ÿ¢ŸÜ ÿ±ÿß ÿ±€åÿ≥ÿ™ ⁄©ŸÜ€åÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:* (ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÜ⁄©ŸÜ€åÿØ)\n\n"
        "ŸÖÿ´ÿßŸÑ: `azumi`",
        parse_mode="Markdown"
    )
    return ENTER_RESET_PEER_NAME


async def reset_peername(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    if not re.match(r"^[a-zA-Z0-9_-]+$", peer_name):
        await update.message.reply_text(
            "‚ùå ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÅŸÇÿ∑ ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ Ÿà ÿßÿπÿØÿßÿØ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ."
        )
        return ENTER_RESET_PEER_NAME

    context.user_data["reset_peer_name"] = peer_name
    selected_interface = context.user_data["selected_reset_interface"]
    try:
        response = await api_stuff(f"api/get-peer-info?peerName={peer_name}&configFile={selected_interface}")
    except Exception as e:
        await update.message.reply_text(
            f"‚ùå *ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±:*\n`{e}`",
            parse_mode="Markdown"
        )
        return ENTER_RESET_PEER_NAME

    if "error" in response:
        await update.message.reply_text(
            f"‚ùå *ÿÆÿ∑ÿß:* `{response['error']}`\n\nÿßÿ∑ŸÖ€åŸÜÿßŸÜ ÿ≠ÿßÿµŸÑ ⁄©ŸÜ€åÿØ ⁄©Ÿá ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± `{selected_interface}` ŸÖŸàÿ¨ŸàÿØ ÿßÿ≥ÿ™.",
            parse_mode="Markdown"
        )
        return ENTER_RESET_PEER_NAME

    peer_info = response.get("peerInfo", {})
    context.user_data["reset_peer_info"] = peer_info
    traffic_used = peer_info.get("used", "ŸÜÿßŸÖÿ¥ÿÆÿµ")
    traffic_limit = peer_info.get("limit", "ŸÜÿßŸÖÿ¥ÿÆÿµ")
    expiry = peer_info.get("remaining_time", "ŸÜÿßŸÖÿ¥ÿÆÿµ")

    keyboard = [
        [InlineKeyboardButton("üîÑ ÿ±€åÿ≥ÿ™ ÿ™ÿ±ÿßŸÅ€å⁄©", callback_data="reset_traffic")],
        [InlineKeyboardButton("‚è≥ ÿ±€åÿ≥ÿ™ ÿßŸÜŸÇÿ∂ÿß", callback_data="reset_expiry")],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿßŸÜÿ™ÿÆÿßÿ® ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥", callback_data="back_to_reset_interface")]
    ]
    await update.message.reply_text(
        f"üë§ *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:* `{peer_name}`\n"
        f"üìä *ÿ™ÿ±ÿßŸÅ€å⁄© ŸÖÿµÿ±ŸÅ ÿ¥ÿØŸá:* `{traffic_used}` / `{traffic_limit}`\n"
        f"‚è≥ *ÿ≤ŸÖÿßŸÜ ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá:* `{expiry} ÿØŸÇ€åŸÇŸá`\n\n"
        "‚öôÔ∏è *€å⁄© ÿπŸÖŸÑ€åÿßÿ™ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return SHOW_PEER_INFO


async def reset_action(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    peer_name = context.user_data["reset_peer_name"]
    selected_interface = context.user_data["selected_reset_interface"]

    if query.data == "reset_traffic":
        payload = {"peerName": peer_name, "config": selected_interface}
        response = await api_stuff("api/reset-traffic", method="POST", data=payload)
        if "error" in response:
            await query.message.reply_text(
                f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ±€åÿ≥ÿ™ ÿ™ÿ±ÿßŸÅ€å⁄©: `{response['error']}`", parse_mode="Markdown"
            )
            return ConversationHandler.END

        await query.message.reply_text(
            f"‚úÖ *ÿ™ÿ±ÿßŸÅ€å⁄© ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± '{peer_name}' ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ±€åÿ≥ÿ™ ÿ¥ÿØ!*", parse_mode="Markdown"
        )

    elif query.data == "reset_expiry":
        payload = {"peerName": peer_name, "config": selected_interface}
        response = await api_stuff("api/reset-expiry", method="POST", data=payload)
        if "error" in response:
            await query.message.reply_text(
                f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ±€åÿ≥ÿ™ ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß: `{response['error']}`", parse_mode="Markdown"
            )
            return ConversationHandler.END

        await query.message.reply_text(
            f"‚úÖ *ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± '{peer_name}' ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ±€åÿ≥ÿ™ ÿ¥ÿØ!*", parse_mode="Markdown"
        )

    keyboard = [
        [InlineKeyboardButton("üîÑ ÿ±€åÿ≥ÿ™ ÿ™ÿ±ÿßŸÅ€å⁄©", callback_data="reset_traffic")],
        [InlineKeyboardButton("üîÑ ÿ±€åÿ≥ÿ™ ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß", callback_data="reset_expiry")],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu")],
        [InlineKeyboardButton("üè† ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å", callback_data="main_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(
        f"üéâ *ÿπŸÖŸÑ€åÿßÿ™ ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± '{peer_name}' ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ!*\n\n"
        "ŸÑÿ∑ŸÅÿßŸã ÿπŸÖŸÑ€åÿßÿ™ ÿØ€å⁄Øÿ±€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ €åÿß ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ:",
        reply_markup=reply_markup,
        parse_mode="Markdown",
    )

    return SHOW_PEER_INFO  


async def edit_peer_init(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return

    response = await api_stuff("api/get-interfaces")
    if "error" in response:
        await context.bot.send_message(chat_id, text=f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥‚ÄåŸáÿß: {response['error']}")
        return ConversationHandler.END

    interfaces = response.get("interfaces", [])
    if not interfaces:
        await context.bot.send_message(chat_id, text="‚ùå *Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*")
        return ConversationHandler.END

    keyboard = [[InlineKeyboardButton(interface, callback_data=f"edit_select_interface_{interface}")] for interface in interfaces]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(chat_id, text="üåê *ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*", reply_markup=reply_markup)
    return STATE_SELECT_INTERFACE


async def edit_select_interface(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_interface = query.data.replace("edit_select_interface_", "")
    context.user_data["selected_interface"] = selected_interface

    response = await api_stuff(f"api/peers-by-interface?interface={selected_interface}")
    if "error" in response:
        await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ: {response['error']}")
        return ConversationHandler.END

    peers = response.get("peers", [])
    if not peers:
        await query.message.reply_text(f"Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿ±ÿß€å ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ **{selected_interface}** €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        return ConversationHandler.END
    displayed_peers = peers[:5]
    keyboard = [[InlineKeyboardButton(peer["peer_name"], callback_data=f"edit_{peer['peer_name']}")] for peer in displayed_peers]
    keyboard.append([InlineKeyboardButton("üîç ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜÿßŸÖ", callback_data="search_peer_name")])
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text(
        "€å⁄© ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ¨ÿ≥ÿ™ÿ¨Ÿà ⁄©ŸÜ€åÿØ:",
        reply_markup=reply_markup
    )
    return STATE_SELECT_PEER_OR_SEARCH


async def search_peername(update: Update, context: CallbackContext):
    await update.callback_query.answer()
    await update.callback_query.message.reply_text(
        "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ™ÿ±ÿßŸÅ€å⁄© €åÿß ÿßŸÜŸÇÿ∂ÿß€å ÿ¢ŸÜ ÿ±ÿß ÿ±€åÿ≥ÿ™ ⁄©ŸÜ€åÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:* (ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÜ⁄©ŸÜ€åÿØ)\n\n"
        "ŸÖÿ´ÿßŸÑ: `azumi`",
        parse_mode="Markdown"
    )
    return STATE_SEARCH_PEER


async def filter_peersname(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    selected_interface = context.user_data.get("selected_interface")

    response = await api_stuff(f"api/peers-by-interface?interface={selected_interface}")
    if "error" in response:
        await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ: {response['error']}")
        return ConversationHandler.END

    peers = response.get("peers", [])
    matched_peers = [peer for peer in peers if peer_name.lower() in peer["peer_name"].lower()]

    if not matched_peers:
        await update.message.reply_text(f"Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ±€å ŸÖÿ∑ÿßÿ®ŸÇ ÿ®ÿß **{peer_name}** €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        return STATE_SEARCH_PEER

    keyboard = [[InlineKeyboardButton(peer["peer_name"], callback_data=f"edit_{peer['peer_name']}")] for peer in matched_peers]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("€å⁄© ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=reply_markup)
    return STATE_SELECT_PEER_TO_EDIT


async def select_peer_to_edit(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_peer = query.data.replace("edit_", "")
    context.user_data["selected_peer"] = selected_peer

    selected_interface = context.user_data["selected_interface"]
    response = await api_stuff(f"api/peers-by-interface?interface={selected_interface}")
    peers = response.get("peers", [])
    peer_data = next((peer for peer in peers if peer["peer_name"] == selected_peer), None)

    if not peer_data:
        await query.message.reply_text(f"‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ: {selected_peer}")
        return ConversationHandler.END

    context.user_data["selected_peer_data"] = peer_data
    current_limit = peer_data.get("limit", "ŸÜÿßŸÖÿ¥ÿÆÿµ")
    expiry_time = peer_data.get("expiry_time", {})
    current_expiry = (
        f"{expiry_time.get('days', 0)} ÿ±Ÿàÿ≤, {expiry_time.get('months', 0)} ŸÖÿßŸá, "
        f"{expiry_time.get('hours', 0)} ÿ≥ÿßÿπÿ™, {expiry_time.get('minutes', 0)} ÿØŸÇ€åŸÇŸá"
    )

    peer_name = peer_data.get("peer_name", "⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿØŸàŸÜ ŸÜÿßŸÖ")
    interface_name = selected_interface

    keyboard = [
        [InlineKeyboardButton("üìù Ÿà€åÿ±ÿß€åÿ¥ ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ", callback_data="edit_data_limit")],
        [InlineKeyboardButton("üåê Ÿà€åÿ±ÿß€åÿ¥ DNS", callback_data="edit_dns")],
        [InlineKeyboardButton("‚è≥ Ÿà€åÿ±ÿß€åÿ¥ ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß", callback_data="edit_expiry_time")],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿßŸÜÿ™ÿÆÿßÿ® ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥", callback_data="edit_peer")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.message.reply_text(
        f"üî∑ **ÿ¨ÿ≤ÿ¶€åÿßÿ™ ÿß⁄©ŸÜŸàŸÜ ⁄©ÿßÿ±ÿ®ÿ±** üî∑\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üìõ **ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:** `{peer_name}`\n"
        f"üåê **ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥:** `{interface_name}`\n"
        f"üì¶ **ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ:** `{current_limit}`\n"
        f"‚è≥ **ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß:** `{current_expiry}`\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    return STATE_EDIT_OPTION


async def edit_data_limit(update: Update, context: CallbackContext):
    await update.callback_query.answer()

    peer_data = context.user_data.get("selected_peer_data", {})
    current_data_limit = peer_data.get("limit", "ŸÜÿßŸÖÿ¥ÿÆÿµ")

    await update.callback_query.message.reply_text(
        f"ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ ŸÅÿπŸÑ€å: **{current_data_limit}**\n"
        "‚úèÔ∏è ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ ÿ¨ÿØ€åÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (ŸÖÿ´ÿßŸÑ: `500MiB` €åÿß `1GiB`):",
        parse_mode="Markdown"
    )
    return STATE_SET_DATA_LIMIT


async def set_data_limit(update: Update, context: CallbackContext):
    data_limit = update.message.text.strip()
    if not re.match(r"^\d+(MiB|GiB)$", data_limit):
        await update.message.reply_text("‚ùå ŸÅÿ±ŸÖÿ™ ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ÿßÿ≤ `500MiB` €åÿß `1GiB` ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.")
        return STATE_SET_DATA_LIMIT

    context.user_data["new_data_limit"] = data_limit
    await update.message.reply_text("ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ. ÿØÿ± ÿ≠ÿßŸÑ ÿ∞ÿÆ€åÿ±Ÿá ÿ™ÿ∫€å€åÿ±ÿßÿ™...")
    await save_peer_changes(update, context)
    return ConversationHandler.END


async def edit_dns(update: Update, context: CallbackContext):
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.message.reply_text(
            "‚úèÔ∏è *ŸÑÿ∑ŸÅÿßŸã ÿ¢ÿØÿ±ÿ≥ Ÿáÿß€å ÿ¨ÿØ€åÿØ DNS ÿ±ÿß Ÿàÿßÿ±ÿØ ŸÜŸÖÿß€å€åÿØ:*",
            parse_mode="Markdown"
        )
        return STATE_SET_DNS

    if update.message:
        dns = update.message.text.strip()
        context.user_data["new_dns"] = dns

        await update.message.reply_text("ÿ¢ÿØÿ±ÿ≥ DNS ÿ®Ÿá ÿ±Ÿàÿ≤ ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ")
        await save_peer_changes(update, context)
        return ConversationHandler.END



async def edit_expiry_time(update: Update, context: CallbackContext):
    await update.callback_query.answer()

    peer_data = context.user_data.get("selected_peer_data", {})
    expiry_time = peer_data.get("expiry_time", {})
    current_expiry = (
        f"{expiry_time.get('days', 0)} ÿ±Ÿàÿ≤, {expiry_time.get('months', 0)} ŸÖÿßŸá, "
        f"{expiry_time.get('hours', 0)} ÿ≥ÿßÿπÿ™, {expiry_time.get('minutes', 0)} ÿØŸÇ€åŸÇŸá"
    )

    await update.callback_query.message.reply_text(
        f"ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß€å ŸÅÿπŸÑ€å: **{current_expiry}**\n"
        "‚úèÔ∏è ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß€å ÿ¨ÿØ€åÿØ ÿ±ÿß ÿ®Ÿá ÿ±Ÿàÿ≤ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (ŸÖÿ´ÿßŸÑ: `10`):",
        parse_mode="Markdown"
    )
    return STATE_SET_EXPIRY_TIME


async def set_expiry_time(update: Update, context: CallbackContext):
    expiry_days = update.message.text.strip()
    if not expiry_days.isdigit() or int(expiry_days) <= 0:
        await update.message.reply_text("‚ùå ŸÖŸÇÿØÿßÿ± ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿπÿØÿØ ŸÖÿ´ÿ®ÿ™ ÿ®ÿ±ÿß€å ÿ±Ÿàÿ≤Ÿáÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.")
        return STATE_SET_EXPIRY_TIME

    context.user_data["new_expiry_days"] = int(expiry_days)
    await update.message.reply_text("ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ. ÿØÿ± ÿ≠ÿßŸÑ ÿ∞ÿÆ€åÿ±Ÿá ÿ™ÿ∫€å€åÿ±ÿßÿ™...")
    await save_peer_changes(update, context)
    return ConversationHandler.END


async def save_peer_changes(update: Update, context: CallbackContext):
    peer_name = context.user_data["selected_peer"]
    selected_interface = context.user_data["selected_interface"]
    new_expiry_days = context.user_data.get("new_expiry_days", 0)
    peer_data = context.user_data.get("selected_peer_data", {})
    expiry_time = peer_data.get("expiry_time", {})
    expiry_time["days"] = new_expiry_days

    payload = {
        "peerName": peer_name,
        "dataLimit": context.user_data.get("new_data_limit"),
        "dns": context.user_data.get("new_dns"),
        "expiryDays": new_expiry_days,
        "expiryMonths": expiry_time.get("months", 0),
        "expiryHours": expiry_time.get("hours", 0),
        "expiryMinutes": expiry_time.get("minutes", 0),
        "configFile": f"{selected_interface}.conf",  
    }

    payload = {key: value for key, value in payload.items() if value is not None}
    print(f"Sending API request with payload: {payload}")

    response = await api_stuff("api/edit-peer", method="POST", data=payload)
    if "error" in response:
        await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ∞ÿÆ€åÿ±Ÿá ÿ™ÿ∫€å€åÿ±ÿßÿ™: {response['error']}")
    else:
        await update.message.reply_text("‚úÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ!")

        keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("ÿπŸÖŸÑ€åÿßÿ™ ÿ®ÿπÿØ€å ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=reply_markup)



async def block_unblock_peer(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    config_dir = "/etc/wireguard/" 

    try:
        configs = [f for f in os.listdir(config_dir) if f.endswith(".conf")]
    except Exception as e:
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ŸÅÿß€åŸÑ‚ÄåŸáÿß€å ⁄©ÿßŸÜŸÅ€å⁄Ø: {e}",
            parse_mode="Markdown",
        )
        return ConversationHandler.END

    if not configs:
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå ŸÅÿß€åŸÑ ⁄©ÿßŸÜŸÅ€å⁄Ø €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.",
            parse_mode="Markdown",
        )
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton(config, callback_data=f"select_config:{config}")]
        for config in configs
    ]
    keyboard.append(
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß", callback_data="peers_menu")]
    )
    reply_markup = InlineKeyboardMarkup(keyboard)
    message = (
        "üîí **ŸÖÿ≥ÿØŸàÿØ/ÿ®ÿßÿ≤⁄©ÿ±ÿØŸÜ ⁄©ÿßÿ±ÿ®ÿ±**\n\n"
        "ŸÑÿ∑ŸÅÿßŸã **ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ** ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ŸÖÿØ€åÿ±€åÿ™ ⁄©ŸÜ€åÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ: üåê"
    )
    await context.bot.send_message(
        chat_id=chat_id, text=message, reply_markup=reply_markup, parse_mode="Markdown"
    )
    return SELECT_CONFIG_DYNAMIC

async def select_config_handler(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    data = query.data
    if data.startswith("select_config:"):
        config_name = data.split("select_config:")[1]
        context.user_data["config_name"] = config_name

        message = (
            "üîí **ŸÖÿ≥ÿØŸàÿØ/ÿ®ÿßÿ≤⁄©ÿ±ÿØŸÜ ⁄©ÿßÿ±ÿ®ÿ±**\n\n"
            "ŸÑÿ∑ŸÅÿßŸã **ŸÜÿßŸÖ** ⁄©ÿßÿ±ÿ®ÿ±€å ÿ±ÿß ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ŸÖÿ≥ÿØŸàÿØ €åÿß ÿ®ÿßÿ≤ ⁄©ŸÜ€åÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:"
        )
        keyboard = [
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿáÿß", callback_data="block_unblock_peer")],
            [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß", callback_data="peers_menu")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.message.edit_text(
            message, reply_markup=reply_markup, parse_mode="Markdown"
        )
        return SELECT_PEER
    elif data == "peers_menu":
        return await peers_menu(update, context)
    else:
        await query.message.reply_text("‚ùå ÿßŸÜÿ™ÿÆÿßÿ® ŸÜÿßŸÖÿπÿ™ÿ®ÿ±.")
        return ConversationHandler.END

async def fetch_config(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    if not re.match(r"^[a-zA-Z0-9_-]+$", peer_name):
        await update.message.reply_text("‚ùå ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ:")
        return SELECT_PEER

    config_name = context.user_data.get("config_name")
    if not config_name:
        await update.message.reply_text("‚ùå Ÿá€å⁄Ü ÿ™ŸÜÿ∏€åŸÖÿßÿ™€å ÿßŸÜÿ™ÿÆÿßÿ® ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ.")
        return ConversationHandler.END

    response = await api_stuff(f"api/peers?config={config_name}&page=1&limit=50")

    if "error" in response:
        await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß: {response['error']}")
        return ConversationHandler.END

    peers = response.get("peers", [])
    matched_peer = next(
        (peer for peer in peers if peer.get("peer_name") == peer_name), None
    )

    if not matched_peer:
        await update.message.reply_text(
            "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ŸÖÿπÿ™ÿ®ÿ±€å Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
            reply_markup=InlineKeyboardMarkup(
                [
                    [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥‚ÄåŸáÿß", callback_data="block_unblock_peer")],
                    [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß", callback_data="peers_menu")],
                ]
            ),
            parse_mode="Markdown",
        )
        return SELECT_PEER

    context.user_data["matched_peer"] = matched_peer

    is_monitor_blocked = matched_peer.get("monitor_blocked", False)
    is_expiry_blocked = matched_peer.get("expiry_blocked", False)
    is_blocked = is_monitor_blocked or is_expiry_blocked  
    status = "ŸÖÿ≥ÿØŸàÿØ ÿ¥ÿØŸá" if is_blocked else "ÿ∫€åÿ±ŸÖÿ≥ÿØŸàÿØ"

    message = (
        f"üîí **ŸÖÿ≥ÿØŸàÿØ ⁄©ÿ±ÿØŸÜ/ÿ±ŸÅÿπ ŸÖÿ≥ÿØŸàÿØ€å ⁄©ÿßÿ±ÿ®ÿ±**\n\n"
        f"üìõ <b>ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:</b> {peer_name}\n"
        f"‚ö° <b>Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπŸÑ€å:</b> {status}\n\n"
        f"ÿ¢€åÿß ŸÖÿß€åŸÑ ÿ®Ÿá ÿ™ÿ∫€å€åÿ± Ÿàÿ∂ÿπ€åÿ™ Ÿáÿ≥ÿ™€åÿØÿü"
    )
    keyboard = [
        [InlineKeyboardButton("‚úÖ ÿ®ŸÑŸá", callback_data="toggle_status")],
        [InlineKeyboardButton("‚ùå ÿÆ€åÿ±", callback_data="peers_menu")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        message, reply_markup=reply_markup, parse_mode="HTML"
    )
    return TOGGLE_BLOCK


async def toggle_block_status(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    matched_peer = context.user_data.get("matched_peer")
    config_name = context.user_data.get("config_name")
    if not matched_peer or not config_name:
        await query.message.reply_text("‚ùå ÿØÿßÿØŸá‚ÄåŸáÿß ŸÜÿßŸÇÿµ Ÿáÿ≥ÿ™ŸÜÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ.")
        return ConversationHandler.END

    is_blocked = matched_peer.get("monitor_blocked", False) or matched_peer.get("expiry_blocked", False)

    new_status = not is_blocked

    if matched_peer.get("monitor_blocked", False):
        matched_peer["monitor_blocked"] = new_status
    if matched_peer.get("expiry_blocked", False):
        matched_peer["expiry_blocked"] = new_status

    data = {
        "peerName": matched_peer["peer_name"],
        "blocked": new_status,
        "config": config_name,
    }

    response = await api_stuff("api/toggle-peer", method="POST", data=data)

    if "error" in response:
        await query.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ™ÿ∫€å€åÿ± Ÿàÿ∂ÿπ€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±: {response['error']}")
        return ConversationHandler.END

    context.user_data["matched_peer"] = matched_peer

    status = "ŸÖÿ≥ÿØŸàÿØ ÿ¥ÿØŸá" if new_status else "ÿ∫€åÿ±ŸÖÿ≥ÿØŸàÿØ"
    message = (
        f"üîí **ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:** {matched_peer['peer_name']}\n"
        f"‚ö° **Ÿàÿ∂ÿπ€åÿ™ ÿ¨ÿØ€åÿØ:** {status}\n\n"
        "‚úÖ Ÿàÿ∂ÿπ€åÿ™ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ!"
    )
    keyboard = [
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±Ÿáÿß", callback_data="peers_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text(
        message, reply_markup=reply_markup, parse_mode="Markdown"
    )
    return ConversationHandler.END



async def peer_status_mnu(update: Update, context: CallbackContext):
    chat_id = update.effective_chat.id
    if not is_authorized(chat_id):
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå You are not authorized to perform this action.",
            parse_mode="Markdown"
        )
        return
    response = await api_stuff("api/get-interfaces")

    if "error" in response:
        await context.bot.send_message(chat_id, f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥‚ÄåŸáÿß: `{response['error']}`", parse_mode="Markdown")
        return ConversationHandler.END

    interfaces = response.get("interfaces", [])
    if not interfaces:
        await context.bot.send_message(chat_id, "‚ùå *Ÿá€å⁄Ü ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥€å ÿ®ÿ±ÿß€å Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.*", parse_mode="Markdown")
        return ConversationHandler.END

    keyboard = [[InlineKeyboardButton(f"üìÇ {interface}", callback_data=f"status_interface_{interface}")]
                for interface in interfaces]
    keyboard.append([InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await context.bot.send_message(
        chat_id,
        "üåê *€å⁄© ÿß€åŸÜÿ™ÿ±ŸÅ€åÿ≥ Ÿàÿß€åÿ±⁄Øÿßÿ±ÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá Ÿàÿ∂ÿπ€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:*",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    return CHOOSE_INTERFACE_STATUS


async def init_status_interface(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    selected_interface = query.data.replace("status_interface_", "") + ".conf"
    context.user_data["selected_status_interface"] = selected_interface

    await query.message.reply_text(
        "‚úèÔ∏è *ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ Ÿàÿ∂ÿπ€åÿ™ ÿ¢ŸÜ ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:* (ÿßÿ≤ ÿ≠ÿ±ŸàŸÅ ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÜ⁄©ŸÜ€åÿØ)\n\n"
        "ŸÖÿ´ÿßŸÑ: `azumi`",
        parse_mode="Markdown"
    )
    return INPUT_PEER_NAME_STATUS


async def obtain_peer_status(update: Update, context: CallbackContext):
    peer_name = update.message.text.strip()
    selected_interface = context.user_data["selected_status_interface"]

    if not peer_name:
        await update.message.reply_text("‚ùå ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± ŸÜŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿÆÿßŸÑ€å ÿ®ÿßÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã €å⁄© ŸÜÿßŸÖ ŸÖÿπÿ™ÿ®ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
        return INPUT_PEER_NAME_STATUS

    try:
        response = await api_stuff(f"api/peers?config={selected_interface}&fetch_all=true")

        if "error" in response:
            await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ: {response['error']}")
            return INPUT_PEER_NAME_STATUS

        peers = response.get("peers", [])

        matched_peers = [
            peer for peer in peers if peer_name.lower() == peer.get("peer_name", "").lower()
        ]

        if not matched_peers:
            await update.message.reply_text(f"‚ùå Ÿá€å⁄Ü ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß ŸÜÿßŸÖ **{peer_name}** €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
            return INPUT_PEER_NAME_STATUS

        messages = []
        for peer in matched_peers:
            remaining_minutes = peer.get("remaining_time", 0)
            if remaining_minutes > 0:
                days = remaining_minutes // 1440
                hours = (remaining_minutes % 1440) // 60
                minutes = remaining_minutes % 60
                remaining_human = f"{days} ÿ±Ÿàÿ≤, {hours} ÿ≥ÿßÿπÿ™, {minutes} ÿØŸÇ€åŸÇŸá"
            else:
                remaining_human = "ŸÖŸÜŸÇÿ∂€å ÿ¥ÿØŸá"

            peer_details = (
                f"üéõ **ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±**\n\n"
                f"üìõ **ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±:** `{peer['peer_name']}`\n"
                f"üåê **ÿ¢€å‚ÄåŸæ€å ⁄©ÿßÿ±ÿ®ÿ±:** `{peer['peer_ip']}`\n"
                f"üîë **⁄©ŸÑ€åÿØ ÿπŸÖŸàŸÖ€å:** `{peer['public_key']}`\n"
                f"üìä **ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≠ÿ¨ŸÖ:** `{peer['limit']}`\n"
                f"üì° **ÿ≠ÿ¨ŸÖ ÿ®ÿßŸÇ€å ŸÖÿßŸÜÿØŸá:** `{peer['remaining_human']}`\n"
                f"üïí **ÿ≤ŸÖÿßŸÜ ÿßŸÜŸÇÿ∂ÿß:** {peer['expiry_time']['days']} ÿ±Ÿàÿ≤, "
                f"{peer['expiry_time']['hours']} ÿ≥ÿßÿπÿ™, {peer['expiry_time']['minutes']} ÿØŸÇ€åŸÇŸá\n"
                f"‚è≥ **ÿ≤ŸÖÿßŸÜ ÿ®ÿßŸÇ€å ŸÖÿßŸÜÿØŸá:** {remaining_human}\n"
                f"‚ö° **Ÿàÿ∂ÿπ€åÿ™:** {'üü¢ ŸÅÿπÿßŸÑ' if not peer['expiry_blocked'] else 'üî¥ ÿ®ŸÑÿß⁄© ÿ¥ÿØŸá'}\n"
            )
            messages.append(peer_details)

        for msg in messages:
            await update.message.reply_text(msg, parse_mode="Markdown")

        keyboard = [[InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ", callback_data="peers_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ:", reply_markup=reply_markup)

        return ConversationHandler.END

    except Exception as e:
        print(f"ÿÆÿ∑ÿß ÿØÿ± Ÿàÿ∂ÿπ€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±: {e}")
        await update.message.reply_text("‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ Ÿàÿ∂ÿπ€åÿ™ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿÆ ÿØÿßÿØ.")
        return INPUT_PEER_NAME_STATUS



async def mnu_back(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    if query.data == "main_menu":
        return await start(update, context) 
    elif query.data == "backups_menu":
        return await backups_menu(update, context)  
    elif query.data == "peers_menu":
        await peers_menu(update, context)  
        return ConversationHandler.END 
    else:
        return await start(update, context)  

 

def main():

    application = (
    ApplicationBuilder()
    .token(TELEGRAM_BOT_TOKEN)
    .connect_timeout(30.0)  
    .read_timeout(30.0)     
    .build()
)
    application.bot_data = {"notifications_enabled": True} 

    block_unblock_stuff = ConversationHandler(
    entry_points=[CallbackQueryHandler(block_unblock_peer, pattern="block_unblock_peer")],
    states={
        SELECT_CONFIG_DYNAMIC: [
            CallbackQueryHandler(select_config_handler, pattern="^select_config:"),
            CallbackQueryHandler(peers_menu, pattern="peers_menu"),
        ],
        SELECT_PEER: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, fetch_config),
            CallbackQueryHandler(block_unblock_peer, pattern="block_unblock_peer"),
            CallbackQueryHandler(peers_menu, pattern="peers_menu"),
        ],
        TOGGLE_BLOCK: [
            CallbackQueryHandler(toggle_block_status, pattern="toggle_status"),
            CallbackQueryHandler(peers_menu, pattern="peers_menu"),
        ],
    },
    fallbacks=[
        CallbackQueryHandler(peers_menu, pattern="peers_menu")
    ],
    allow_reentry=True,
)
    stuff_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(download_qr_menu, pattern="download_qr_menu")],
    states={
        SELECT_PEER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, peername_search)],
        SELECT_INTERFACE: [CallbackQueryHandler(interface_select, pattern="^select_interface_.*$")],
        VIEW_PEER_DETAILS: [MessageHandler(filters.TEXT & ~filters.COMMAND, peername_search)], 
        ConversationHandler.END: [CallbackQueryHandler(peer_decision, pattern="^(download|qr)_.*")]
    },
    fallbacks=[CallbackQueryHandler(peers_menu, pattern="main_menu")],
    allow_reentry=True,
)

    peer_creation_stuff = ConversationHandler(
    entry_points=[CallbackQueryHandler(init_peer_create, pattern="create_peer")],
    states={
        SELECT_MODE: [CallbackQueryHandler(select_mode, pattern="mode_.*")],
        SELECT_CONFIG: [CallbackQueryHandler(select_config, pattern="config_.*")],
        SELECT_IP_ADDRESS: [CallbackQueryHandler(choose_ip, pattern="ip_.*")],
        INPUT_BULK_COUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, write_bulk_count)],
        INPUT_PEER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, input_peer_name)],
        SELECT_LIMIT_UNIT: [CallbackQueryHandler(choose_limit_unit, pattern="unit_.*")],
        INPUT_LIMIT_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, choose_limit_value)],
        SELECT_DNS: [CallbackQueryHandler(select_dns, pattern="dns_.*")],
        INPUT_CUSTOM_DNS: [MessageHandler(filters.TEXT & ~filters.COMMAND, write_custom_dns)],
        INPUT_EXPIRY_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, write_expiry_days)],
        INPUT_MTU: [MessageHandler(filters.TEXT & ~filters.COMMAND, write_mtu)],
        INPUT_KEEPALIVE: [MessageHandler(filters.TEXT & ~filters.COMMAND, write_keepalive)],  
        CONFIRM_USAGE: [CallbackQueryHandler(confirm_use, pattern="confirm_usage_.*")],
        ConversationHandler.END: [
            CallbackQueryHandler(download_peerconfig_general, pattern="download_general_.*"),
            CallbackQueryHandler(generate_peerqr_general, pattern="qr_general_.*")
        ]
    },
    fallbacks=[],
    allow_reentry=True,
)

    
    peer_edit_stuff = ConversationHandler(
    entry_points=[CallbackQueryHandler(edit_peer_init, pattern="edit_peer")],
    states={
        STATE_SELECT_INTERFACE: [CallbackQueryHandler(edit_select_interface, pattern="edit_select_interface_.*")],
        STATE_SELECT_PEER_OR_SEARCH: [
            CallbackQueryHandler(select_peer_to_edit, pattern="edit_.*"),
            CallbackQueryHandler(search_peername, pattern="search_peer_name"),
        ],
        STATE_SEARCH_PEER: [MessageHandler(filters.TEXT & ~filters.COMMAND, filter_peersname)],
        STATE_SELECT_PEER_TO_EDIT: [CallbackQueryHandler(select_peer_to_edit, pattern="edit_.*")],
        STATE_EDIT_OPTION: [
            CallbackQueryHandler(edit_data_limit, pattern="edit_data_limit"),
            CallbackQueryHandler(edit_dns, pattern="edit_dns"),
            CallbackQueryHandler(edit_expiry_time, pattern="edit_expiry_time"),
        ],
        STATE_SET_DATA_LIMIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_data_limit)],
        STATE_SET_DNS: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_dns)],
        STATE_SET_EXPIRY_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_expiry_time)],
    },
    fallbacks=[CallbackQueryHandler(edit_peer_init, pattern="edit_peer")],
    allow_reentry=True,
)
    
    delete_peer_stuff = ConversationHandler(
    entry_points=[CallbackQueryHandler(init_deletepeer, pattern="peer_delete")],
    states={
        CHOOSE_WG_INTERFACE: [CallbackQueryHandler(select_interface_delete, pattern="peer_interface_.*")],
        ENTER_PEER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, specify_peername_delete)],
        CONFIRM_PEER_DELETION: [CallbackQueryHandler(apply_peer_deletion, pattern="peer_confirm_delete|peer_back_to_interface")]
    },
    fallbacks=[],
    allow_reentry=True,
)

    reset_peer_stuff = ConversationHandler(
    entry_points=[CallbackQueryHandler(init_resetpeer, pattern="reset_peer")],
    states={
        SELECT_RESET_INTERFACE: [CallbackQueryHandler(select_reset_interface, pattern="reset_interface_.*")],
        ENTER_RESET_PEER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, reset_peername)],
        SHOW_PEER_INFO: [CallbackQueryHandler(reset_action, pattern="reset_traffic|reset_expiry|back_to_reset_interface")]
    },
    fallbacks=[],
    allow_reentry=True,
)
    
    peer_status_stuff = ConversationHandler(
    entry_points=[CallbackQueryHandler(peer_status_mnu, pattern="peer_status")],
    states={
        CHOOSE_INTERFACE_STATUS: [CallbackQueryHandler(init_status_interface, pattern="status_interface_.*")],
        INPUT_PEER_NAME_STATUS: [MessageHandler(filters.TEXT & ~filters.COMMAND, obtain_peer_status)],
    },
    fallbacks=[CallbackQueryHandler(peer_status_mnu, pattern="peers_menu")],
    allow_reentry=True,
)
    
    user_conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(update_user_wire, pattern="update_user")],
    states={
        USER_UPDATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_username)],
        PASSWORD_UPDATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_password)],
    },
    fallbacks=[CallbackQueryHandler(settings_menu, pattern="settings_menu")]
)
    
    wireguard_conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(update_wireguard_setting, pattern="update_wireguard_config")],
    states={
        CONFIG_INTERFACE: [
            CallbackQueryHandler(ask_for_port, pattern="update_port"),
            CallbackQueryHandler(ask_for_mtu, pattern="update_mtu"),
            CallbackQueryHandler(ask_for_dns, pattern="update_dns"),
            CallbackQueryHandler(apply_config, pattern="apply_changes"),
            CallbackQueryHandler(settings_menu, pattern="settings_menu")
        ],
        CONFIG_PORT: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_port)],
        CONFIG_MTU: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_mtu)],
        CONFIG_DNS: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_dns)],
    },
    fallbacks=[CallbackQueryHandler(settings_menu, pattern="settings_menu")],
)


    login_conv_handler = ConversationHandler(
    entry_points=[CommandHandler("login", start_login), CallbackQueryHandler(start_login, pattern="login")],
    states={
        LOGIN_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, login_username)],
        LOGIN_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, login_password)],
    },
    fallbacks=[],
)
    application.add_handler(ConversationHandler(
    entry_points=[
        CallbackQueryHandler(view_template_menu, pattern="view_template")
    ],
    states={
        SELECT_TEMPLATE_INTERFACE: [
            CallbackQueryHandler(wire_int_selection, pattern="select_template_interface_.*")
        ],
        VIEW_TEMPLATE_PEER_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, view_peers_with_name)
        ],
        SELECT_TEMPLATE_PEER: [
            CallbackQueryHandler(generate_template_with_qr, pattern="view_template_.*")
        ],
    },
    fallbacks=[
        CallbackQueryHandler(mnu_back, pattern=".*_menu"),  
        MessageHandler(filters.COMMAND, lambda update, context: ConversationHandler.END)
    ],
))


    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(start, pattern="start_action"))
    application.add_handler(CallbackQueryHandler(peers_menu, pattern="peers_menu"))
    application.add_handler(peer_status_stuff)
    application.add_handler(block_unblock_stuff)
    application.add_handler(stuff_handler)
    application.add_handler(CallbackQueryHandler(stat_metrics, pattern="metrics"))
    application.add_handler(CallbackQueryHandler(mnu_back, pattern="main_menu"))
    register_backup_stuff(application)
    application.add_handler(peer_creation_stuff)
    application.add_handler(peer_edit_stuff)
    application.add_handler(delete_peer_stuff)
    application.add_handler(reset_peer_stuff)
    application.add_handler(CallbackQueryHandler(download_peerconfig_create, pattern="^download_create_.*$"))
    application.add_handler(CallbackQueryHandler(download_peerconfig_general, pattern="^download_general_.*$"))
    application.add_handler(CallbackQueryHandler(generate_peerqr_create, pattern="^qr_create_.*$"))
    application.add_handler(CallbackQueryHandler(generate_peerqr_general, pattern="^qr_general_.*$"))

    job_queue = application.job_queue
    job_queue.run_once(monitor_health, 1)
    register_notification(application)
    application.add_handler(CallbackQueryHandler(settings_menu, pattern="settings_menu"))
    application.add_handler(wireguard_conv_handler)
    application.add_handler(user_conv_handler)
    application.add_handler(login_conv_handler)
    application.add_handler(CallbackQueryHandler(start_login, pattern="login"))
    application.add_handler(CallbackQueryHandler(logout, pattern="logout"))
    job_queue = application.job_queue
    job_queue.run_once(auto_message, when=1)
    application.add_handler(CallbackQueryHandler(view_logs, pattern="view_logs"))

    print("Wire Bot is running..")
    application.run_polling()

main()
